###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.50.0.51878/W32 for ARM     14/Mar/2021  19:14:53 #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\Projects\in-18-nixie-clock\at91lib\utility\trace.c    #
#    Command line =  C:\Projects\in-18-nixie-clock\at91lib\utility\trace.c    #
#                    -D at91sam7s128 -D flash -D TRACE_LEVEL=3 -lC            #
#                    C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\at91sam7s128_flash\List\ --remarks  #
#                    --diag_suppress Pe826,Pe1375 -o                          #
#                    C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\at91sam7s128_flash\Obj\ --debug     #
#                    --endian=little --cpu=ARM7TDMI -e --fpu=None             #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Full. #
#                    h" -I C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-dev #
#                    ice-cdc-serial-project\ewp\..\..\..\at91lib/peripherals\ #
#                     -I C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-devic #
#                    e-cdc-serial-project\ewp\..\..\..\at91lib/components\    #
#                    -I C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device #
#                    -cdc-serial-project\ewp\..\..\..\at91lib/usb/device\ -I  #
#                    C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\..\..\..\at91lib\ -I                #
#                    C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\..\..\..\external_libs\ -I          #
#                    C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\..\..\..\at91lib/boards/at91sam7s-e #
#                    k\ -I "C:\Program Files (x86)\IAR Systems\Embedded       #
#                    Workbench 5.4\arm\INC\" --interwork --cpu_mode arm -Ohz  #
#    List file    =  C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\at91sam7s128_flash\List\trace.lst   #
#    Object file  =  C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\at91sam7s128_flash\Obj\trace.o      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Projects\in-18-nixie-clock\at91lib\utility\trace.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          
     31          //------------------------------------------------------------------------------
     32          //         Headers
     33          //------------------------------------------------------------------------------
     34          
     35          #include "trace.h"
     36          
     37          //------------------------------------------------------------------------------
     38          //         Internal variables
     39          //------------------------------------------------------------------------------
     40          
     41          /// Trace level can be set at applet initialization
     42          #if !defined(NOTRACE) && (DYN_TRACES == 1)
     43              unsigned int traceLevel = TRACE_LEVEL;
     44          #endif
     45            
     46          #ifndef NOFPUT
     47          #include <stdio.h>
     48          #include <stdarg.h>
     49          
     50          //------------------------------------------------------------------------------
     51          /// \exclude
     52          /// Implementation of fputc using the DBGU as the standard output. Required
     53          /// for printf().
     54          /// \param c  Character to write.
     55          /// \param pStream  Output stream.
     56          /// \param The character written if successful, or -1 if the output stream is
     57          /// not stdout or stderr.
     58          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     59          signed int fputc(signed int c, FILE *pStream)
     60          {
   \                     fputc:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     61              if ((pStream == stdout) || (pStream == stderr)) {
   \   00000008   ........           LDR      R0,??DataTable6_5
   \   0000000C   000051E1           CMP      R1,R0
   \   00000010   ........           LDRNE    R0,??DataTable6_6
   \   00000014   00005111           CMPNE    R1,R0
   \   00000018   0300001A           BNE      ??fputc_0
     62          
     63                  TRACE_PutChar(c);
   \   0000001C   FF0004E2           AND      R0,R4,#0xFF
   \   00000020   ........           BL       DBGU_PutChar
     64                  return c;
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   000000EA           B        ??fputc_1
     65              }
     66              else {
     67          
     68                  return EOF;
   \                     ??fputc_0:
   \   0000002C   0000E0E3           MVN      R0,#+0
   \                     ??fputc_1:
   \   00000030   1040BDE8           POP      {R4,LR}
   \   00000034   1EFF2FE1           BX       LR               ;; return
     69              }
     70          }
     71          
     72          //------------------------------------------------------------------------------
     73          /// \exclude
     74          /// Implementation of fputs using the DBGU as the standard output. Required
     75          /// for printf(). Does NOT currently use the PDC.
     76          /// \param pStr  String to write.
     77          /// \param pStream  Output stream.
     78          /// \return Number of characters written if successful, or -1 if the output
     79          /// stream is not stdout or stderr.
     80          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     81          signed int fputs(const char *pStr, FILE *pStream)
     82          {
   \                     fputs:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
     83              signed int num = 0;
   \   0000000C   0060A0E3           MOV      R6,#+0
   \   00000010   000000EA           B        ??fputs_0
     84          
     85              while (*pStr != 0) {
     86          
     87                  if (fputc(*pStr, pStream) == -1) {
     88          
     89                      return -1;
     90                  }
     91                  num++;
   \                     ??fputs_1:
   \   00000014   016086E2           ADD      R6,R6,#+1
     92                  pStr++;
   \                     ??fputs_0:
   \   00000018   0000D4E5           LDRB     R0,[R4, #+0]
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0600000A           BEQ      ??fputs_2
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0100D4E4           LDRB     R0,[R4], #+1
   \   0000002C   ........           BL       fputc
   \   00000030   010070E3           CMN      R0,#+1
   \   00000034   F6FFFF1A           BNE      ??fputs_1
   \   00000038   0000E0E3           MVN      R0,#+0
   \   0000003C   000000EA           B        ??fputs_3
     93              }
     94          
     95              return num;
   \                     ??fputs_2:
   \   00000040   0600A0E1           MOV      R0,R6
   \                     ??fputs_3:
   \   00000044   7040BDE8           POP      {R4-R6,LR}
   \   00000048   1EFF2FE1           BX       LR               ;; return
     96          }
     97          
     98          #undef putchar
     99          
    100          //------------------------------------------------------------------------------
    101          /// \exclude
    102          /// Outputs a character on the DBGU.
    103          /// \param c  Character to output.
    104          /// \return The character that was output.
    105          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    106          signed int putchar(signed int c)
    107          {
    108              return fputc(c, stdout);
   \                     putchar:
   \   00000000   ........           LDR      R1,??DataTable6_5
   \   00000004   ........           B        fputc            ;; tailcall
    109          }
    110          
    111          #endif //#ifndef NOFPUT
    112          
    113          //------------------------------------------------------------------------------
    114          //         Local Functions
    115          //------------------------------------------------------------------------------
    116          
    117          //------------------------------------------------------------------------------
    118          /// Print char if printable. If not print a point
    119          /// \param c char to
    120          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    121          static void PrintChar(unsigned char c)
    122          {
   \                     PrintChar:
   \   00000000   00502DE9           PUSH     {R12,LR}
    123              if( (/*c >= 0x00 &&*/ c <= 0x1F) ||
    124                  (c >= 0xB0 && c <= 0xDF) ) {
   \   00000004   200050E3           CMP      R0,#+32
   \   00000008   50108022           ADDCS    R1,R0,#+80
   \   0000000C   FF100122           ANDCS    R1,R1,#0xFF
   \   00000010   30005123           CMPCS    R1,#+48
   \   00000014   0200002A           BCS      ??PrintChar_0
    125          
    126                 printf(".");
   \   00000018   ........           ADR      R0,??DataTable6  ;; "."
   \   0000001C   ........           BL       printf
   \   00000020   020000EA           B        ??PrintChar_1
    127              }
    128              else {
    129          
    130                 printf("%c", c);
   \                     ??PrintChar_0:
   \   00000024   0010A0E1           MOV      R1,R0
   \   00000028   ........           ADR      R0,??DataTable6_1  ;; 0x25, 0x63, 0x00, 0x00
   \   0000002C   ........           BL       printf
    131              }
    132          }
   \                     ??PrintChar_1:
   \   00000030   0140BDE8           POP      {R0,LR}
   \   00000034   1EFF2FE1           BX       LR               ;; return
    133          
    134          //------------------------------------------------------------------------------
    135          //         Global Functions
    136          //------------------------------------------------------------------------------
    137          
    138          //------------------------------------------------------------------------------
    139          /// Displays the content of the given frame on the Trace interface.
    140          /// \param pBuffer  Pointer to the frame to dump.
    141          /// \param size  Buffer size in bytes.
    142          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    143          void TRACE_DumpFrame(unsigned char *pFrame, unsigned int size)
    144          {
   \                     TRACE_DumpFrame:
   \   00000000   F8402DE9           PUSH     {R3-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    145              unsigned int i;
    146          
    147              for (i=0; i < size; i++) {
   \   0000000C   0060A0E3           MOV      R6,#+0
   \   00000010   ........           LDR      R7,??DataTable6_7
   \   00000014   030000EA           B        ??TRACE_DumpFrame_0
    148                  printf("%02X ", pFrame[i]);
   \                     ??TRACE_DumpFrame_1:
   \   00000018   0410D6E7           LDRB     R1,[R6, +R4]
   \   0000001C   0700A0E1           MOV      R0,R7
   \   00000020   ........           BL       printf
    149              }
   \   00000024   016086E2           ADD      R6,R6,#+1
   \                     ??TRACE_DumpFrame_0:
   \   00000028   050056E1           CMP      R6,R5
   \   0000002C   F9FFFF3A           BCC      ??TRACE_DumpFrame_1
    150          
    151              printf("\n\r");
   \   00000030   ........           ADR      R0,??DataTable6_2  ;; 0x0A, 0x0D, 0x00, 0x00
   \   00000034   F240BDE8           POP      {R1,R4-R7,LR}
   \   00000038   ........           B        printf           ;; tailcall
    152          }
    153          
    154          //------------------------------------------------------------------------------
    155          /// Displays the content of the given buffer on the Trace interface.
    156          /// \param pBuffer  Pointer to the buffer to dump.
    157          /// \param size     Buffer size in bytes.
    158          /// \param address  Start address to display
    159          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    160          void TRACE_DumpMemory(
    161              unsigned char *pBuffer,
    162              unsigned int size,
    163              unsigned int address
    164              )
    165          {
   \                     TRACE_DumpMemory:
   \   00000000   F44F2DE9           PUSH     {R2,R4-R11,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
    166              unsigned int i, j;
    167              unsigned int lastLineStart;
    168              unsigned char* pTmp;
    169          
    170              for (i=0; i < (size / 16); i++) {
   \   00000010   0080A0E3           MOV      R8,#+0
   \   00000014   ........           ADR      R6,??DataTable6_2  ;; 0x0A, 0x0D, 0x00, 0x00
   \   00000018   ........           LDR      R7,??DataTable6_8
   \   0000001C   170000EA           B        ??TRACE_DumpMemory_0
    171          
    172                  printf("0x%08X: ", address + (i*16));
   \                     ??TRACE_DumpMemory_1:
   \   00000020   08009DE5           LDR      R0,[SP, #+8]
   \   00000024   081280E0           ADD      R1,R0,R8, LSL #+4
   \   00000028   0700A0E1           MOV      R0,R7
   \   0000002C   ........           BL       printf
    173                  pTmp = (unsigned char*)&pBuffer[i*16];
   \   00000030   089284E0           ADD      R9,R4,R8, LSL #+4
   \   00000034   09A0A0E1           MOV      R10,R9
    174                  for (j=0; j < 4; j++) {
   \   00000038   04B0A0E3           MOV      R11,#+4
    175                      printf("%02X%02X%02X%02X ", pTmp[0],pTmp[1],pTmp[2],pTmp[3]);
   \                     ??TRACE_DumpMemory_2:
   \   0000003C   0300DAE5           LDRB     R0,[R10, #+3]
   \   00000040   00008DE5           STR      R0,[SP, #+0]
   \   00000044   0230DAE5           LDRB     R3,[R10, #+2]
   \   00000048   0120DAE5           LDRB     R2,[R10, #+1]
   \   0000004C   0410DAE4           LDRB     R1,[R10], #+4
   \   00000050   0C0087E2           ADD      R0,R7,#+12
   \   00000054   ........           BL       printf
    176                      pTmp += 4;
    177                  }
   \   00000058   01B05BE2           SUBS     R11,R11,#+1
   \   0000005C   F6FFFF1A           BNE      ??TRACE_DumpMemory_2
    178          
    179                  pTmp = (unsigned char*)&pBuffer[i*16];
    180                  for (j=0; j < 16; j++) {
   \   00000060   10A0A0E3           MOV      R10,#+16
    181                      PrintChar(*pTmp++);
   \                     ??TRACE_DumpMemory_3:
   \   00000064   0100D9E4           LDRB     R0,[R9], #+1
   \   00000068   ........           BL       PrintChar
    182                  }
   \   0000006C   01A05AE2           SUBS     R10,R10,#+1
   \   00000070   FBFFFF1A           BNE      ??TRACE_DumpMemory_3
    183          
    184                  printf("\n\r");
   \   00000074   0600A0E1           MOV      R0,R6
   \   00000078   ........           BL       printf
    185              }
   \   0000007C   018088E2           ADD      R8,R8,#+1
   \                     ??TRACE_DumpMemory_0:
   \   00000080   250258E1           CMP      R8,R5, LSR #+4
   \   00000084   E5FFFF3A           BCC      ??TRACE_DumpMemory_1
    186          
    187              if( (size%16) != 0) {
   \   00000088   0F0015E3           TST      R5,#0xF
   \   0000008C   2500000A           BEQ      ??TRACE_DumpMemory_4
    188                  lastLineStart = size - (size%16);
   \   00000090   0F0005E2           AND      R0,R5,#0xF
   \   00000094   008045E0           SUB      R8,R5,R0
    189                  printf("0x%08X: ", address + lastLineStart);
   \   00000098   08009DE5           LDR      R0,[SP, #+8]
   \   0000009C   001088E0           ADD      R1,R8,R0
   \   000000A0   0700A0E1           MOV      R0,R7
   \   000000A4   ........           BL       printf
    190          
    191                  for (j= lastLineStart; j < lastLineStart+16; j++) {
   \   000000A8   08B0A0E1           MOV      R11,R8
   \   000000AC   ........           ADR      R9,??DataTable6_3  ;; 0x20, 0x20, 0x00, 0x00
   \   000000B0   ........           ADR      R10,??DataTable6_4  ;; " "
   \   000000B4   020000EA           B        ??TRACE_DumpMemory_5
    192          
    193                      if( (j!=lastLineStart) && (j%4 == 0) ) {
    194                          printf(" ");
    195                      }
    196                      if(j<size) {
    197                          printf("%02X", pBuffer[j]);
    198                      }
    199                      else {
    200                          printf("  ");
   \                     ??TRACE_DumpMemory_6:
   \   000000B8   0900A0E1           MOV      R0,R9
   \   000000BC   ........           BL       printf
    201                      }
   \                     ??TRACE_DumpMemory_7:
   \   000000C0   01B08BE2           ADD      R11,R11,#+1
   \                     ??TRACE_DumpMemory_5:
   \   000000C4   100088E2           ADD      R0,R8,#+16
   \   000000C8   00005BE1           CMP      R11,R0
   \   000000CC   0B00002A           BCS      ??TRACE_DumpMemory_8
   \   000000D0   08005BE1           CMP      R11,R8
   \   000000D4   0300000A           BEQ      ??TRACE_DumpMemory_9
   \   000000D8   03001BE3           TST      R11,#0x3
   \   000000DC   0100001A           BNE      ??TRACE_DumpMemory_9
   \   000000E0   0A00A0E1           MOV      R0,R10
   \   000000E4   ........           BL       printf
   \                     ??TRACE_DumpMemory_9:
   \   000000E8   05005BE1           CMP      R11,R5
   \   000000EC   F1FFFF2A           BCS      ??TRACE_DumpMemory_6
   \   000000F0   0410DBE7           LDRB     R1,[R11, +R4]
   \   000000F4   200087E2           ADD      R0,R7,#+32
   \   000000F8   ........           BL       printf
   \   000000FC   EFFFFFEA           B        ??TRACE_DumpMemory_7
    202                  }
    203          
    204                  printf(" ");
   \                     ??TRACE_DumpMemory_8:
   \   00000100   0A00A0E1           MOV      R0,R10
   \   00000104   ........           BL       printf
    205                  for (j= lastLineStart; j <size; j++) {
   \   00000108   020000EA           B        ??TRACE_DumpMemory_10
    206                      PrintChar(pBuffer[j]);
   \                     ??TRACE_DumpMemory_11:
   \   0000010C   0400D8E7           LDRB     R0,[R8, +R4]
   \   00000110   ........           BL       PrintChar
    207                  }
   \   00000114   018088E2           ADD      R8,R8,#+1
   \                     ??TRACE_DumpMemory_10:
   \   00000118   050058E1           CMP      R8,R5
   \   0000011C   FAFFFF3A           BCC      ??TRACE_DumpMemory_11
    208          
    209                  printf("\n\r");
   \   00000120   0600A0E1           MOV      R0,R6
   \   00000124   ........           BL       printf
    210              }
    211          }
   \                     ??TRACE_DumpMemory_4:
   \   00000128   F74FBDE8           POP      {R0-R2,R4-R11,LR}
   \   0000012C   1EFF2FE1           BX       LR               ;; return
    212              
    213          //------------------------------------------------------------------------------
    214          /// Reads an integer
    215          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    216          unsigned char TRACE_GetInteger(unsigned int *pValue)
    217          {
   \                     TRACE_GetInteger:
   \   00000000   F8402DE9           PUSH     {R3-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    218              unsigned char key;
    219              unsigned char nbNb = 0;
   \   00000008   0050A0E3           MOV      R5,#+0
    220              unsigned int value = 0;
   \   0000000C   0060A0E3           MOV      R6,#+0
   \   00000010   040000EA           B        ??TRACE_GetInteger_0
    221              while(1) {
    222                  key = TRACE_GetChar();
    223                  TRACE_PutChar(key);
    224                  if(key >= '0' &&  key <= '9' ) {
    225                      value = (value * 10) + (key - '0');
   \                     ??TRACE_GetInteger_1:
   \   00000014   0A00A0E3           MOV      R0,#+10
   \   00000018   907621E0           MLA      R1,R0,R6,R7
   \   0000001C   306041E2           SUB      R6,R1,#+48
    226                      nbNb++;
   \   00000020   015085E2           ADD      R5,R5,#+1
   \   00000024   FF5005E2           AND      R5,R5,#0xFF
    227                  }
   \                     ??TRACE_GetInteger_0:
   \   00000028   ........           BL       DBGU_GetChar
   \   0000002C   0070A0E1           MOV      R7,R0
   \   00000030   ........           BL       DBGU_PutChar
   \   00000034   300047E2           SUB      R0,R7,#+48
   \   00000038   0A0050E3           CMP      R0,#+10
   \   0000003C   F4FFFF3A           BCC      ??TRACE_GetInteger_1
    228                  else if(key == 0x0D || key == ' ') {
   \   00000040   ........           LDR      R0,??DataTable6_9
   \   00000044   0D0057E3           CMP      R7,#+13
   \   00000048   20005713           CMPNE    R7,#+32
   \   0000004C   0800001A           BNE      ??TRACE_GetInteger_2
    229                      if(nbNb == 0) {
   \   00000050   000055E3           CMP      R5,#+0
   \   00000054   0100001A           BNE      ??TRACE_GetInteger_3
    230                          printf("\n\rWrite a number and press ENTER or SPACE!\n\r");       
   \   00000058   ........           BL       printf
    231                          return 0; 
   \   0000005C   070000EA           B        ??TRACE_GetInteger_4
    232                      } else {
    233                          printf("\n\r"); 
   \                     ??TRACE_GetInteger_3:
   \   00000060   ........           ADR      R0,??DataTable6_2  ;; 0x0A, 0x0D, 0x00, 0x00
   \   00000064   ........           BL       printf
    234                          *pValue = value;
   \   00000068   006084E5           STR      R6,[R4, #+0]
    235                          return 1;
   \   0000006C   0100A0E3           MOV      R0,#+1
   \   00000070   030000EA           B        ??TRACE_GetInteger_5
    236                      }
    237                  } else {
    238                      printf("\n\r'%c' not a number!\n\r", key);
   \                     ??TRACE_GetInteger_2:
   \   00000074   0710A0E1           MOV      R1,R7
   \   00000078   300080E2           ADD      R0,R0,#+48
   \   0000007C   ........           BL       printf
    239                      return 0;  
   \                     ??TRACE_GetInteger_4:
   \   00000080   0000A0E3           MOV      R0,#+0
    240                  }
    241              }
   \                     ??TRACE_GetInteger_5:
   \   00000084                      REQUIRE ?Subroutine0
   \   00000084                      ;; // Fall through to label ?Subroutine0
    242          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine0:
   \   00000000   F240BDE8           POP      {R1,R4-R7,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
    243          
    244          //------------------------------------------------------------------------------
    245          /// Reads an integer and check the value
    246          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    247          unsigned char TRACE_GetIntegerMinMax(
    248              unsigned int *pValue, 
    249              unsigned int min, 
    250              unsigned int max
    251              )
    252          {
   \                     TRACE_GetIntegerMinMax:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
    253              unsigned int value = 0;
   \   00000014   0010A0E3           MOV      R1,#+0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
    254          
    255              if( TRACE_GetInteger(&value) == 0) {
   \   0000001C   0D00A0E1           MOV      R0,SP
   \   00000020   ........           BL       TRACE_GetInteger
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0E00000A           BEQ      ??TRACE_GetIntegerMinMax_0
    256                  return 0;
    257              }
    258              
    259              if(value < min || value > max) {
   \   0000002C   00009DE5           LDR      R0,[SP, #+0]
   \   00000030   050050E1           CMP      R0,R5
   \   00000034   00005621           CMPCS    R6,R0
   \   00000038   0500002A           BCS      ??TRACE_GetIntegerMinMax_1
    260                  printf("\n\rThe number have to be between %d and %d\n\r", min, max);
                                                                                   ^
Remark[Pe181]: argument is incompatible with corresponding format string
          conversion

          printf("\n\rThe number have to be between %d and %d\n\r", min, max);
                                                                         ^
"C:\Projects\in-18-nixie-clock\at91lib\utility\trace.c",260  Remark[Pe181]: 
          argument is incompatible with corresponding format string conversion
   \   0000003C   0620A0E1           MOV      R2,R6
   \   00000040   0510A0E1           MOV      R1,R5
   \   00000044   ........           LDR      R0,??DataTable6_10
   \   00000048   ........           BL       printf
    261                  return 0; 
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   040000EA           B        ??TRACE_GetIntegerMinMax_0
    262              }
    263          
    264              printf("\n\r"); 
   \                     ??TRACE_GetIntegerMinMax_1:
   \   00000054   ........           ADR      R0,??DataTable6_2  ;; 0x0A, 0x0D, 0x00, 0x00
   \   00000058   ........           BL       printf
    265              *pValue = value;
   \   0000005C   00009DE5           LDR      R0,[SP, #+0]
   \   00000060   000084E5           STR      R0,[R4, #+0]
    266              return 1;
   \   00000064   0100A0E3           MOV      R0,#+1
   \                     ??TRACE_GetIntegerMinMax_0:
   \   00000068   7640BDE8           POP      {R1,R2,R4-R6,LR}
   \   0000006C   1EFF2FE1           BX       LR               ;; return
    267          }
    268          
    269          //------------------------------------------------------------------------------
    270          /// Reads an hexadecimal number
    271          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    272          unsigned char TRACE_GetHexa32(unsigned int *pValue)
    273          {
   \                     TRACE_GetHexa32:
   \   00000000   F8402DE9           PUSH     {R3-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    274              unsigned char key;
    275              unsigned int i = 0;
    276              unsigned int value = 0;
   \   00000008   0050A0E3           MOV      R5,#+0
    277              for(i = 0; i < 8; i++) {
   \   0000000C   0060A0E3           MOV      R6,#+0
    278                  key = TRACE_GetChar();
   \                     ??TRACE_GetHexa32_0:
   \   00000010   ........           BL       DBGU_GetChar
   \   00000014   0070A0E1           MOV      R7,R0
    279                  TRACE_PutChar(key);
   \   00000018   ........           BL       DBGU_PutChar
    280                  if(key >= '0' &&  key <= '9' ) {
   \   0000001C   050287E0           ADD      R0,R7,R5, LSL #+4
   \   00000020   301047E2           SUB      R1,R7,#+48
   \   00000024   0A0051E3           CMP      R1,#+10
   \   00000028   0800002A           BCS      ??TRACE_GetHexa32_1
    281                      value = (value * 16) + (key - '0');
   \   0000002C   305040E2           SUB      R5,R0,#+48
    282                  }
   \                     ??TRACE_GetHexa32_2:
   \   00000030   016086E2           ADD      R6,R6,#+1
   \   00000034   080056E3           CMP      R6,#+8
   \   00000038   F4FFFF3A           BCC      ??TRACE_GetHexa32_0
    283                  else if(key >= 'A' &&  key <= 'F' ) {
    284                      value = (value * 16) + (key - 'A' + 10) ;
    285                  }
    286                  else if(key >= 'a' &&  key <= 'f' ) {
    287                      value = (value * 16) + (key - 'a' + 10) ;
    288                  }        
    289                  else {
    290                      printf("\n\rIt is not a hexa character!\n\r");       
    291                      return 0; 
    292                  }
    293              }
    294          
    295              printf("\n\r");    
   \   0000003C   ........           ADR      R0,??DataTable6_2  ;; 0x0A, 0x0D, 0x00, 0x00
   \   00000040   ........           BL       printf
    296              *pValue = value;     
   \   00000044   005084E5           STR      R5,[R4, #+0]
    297              return 1;
   \   00000048   0100A0E3           MOV      R0,#+1
   \                     ??TRACE_GetHexa32_3:
   \   0000004C   ........           B        ?Subroutine0
   \                     ??TRACE_GetHexa32_1:
   \   00000050   411047E2           SUB      R1,R7,#+65
   \   00000054   060051E3           CMP      R1,#+6
   \   00000058   37504032           SUBCC    R5,R0,#+55
   \   0000005C   F3FFFF3A           BCC      ??TRACE_GetHexa32_2
   \   00000060   611047E2           SUB      R1,R7,#+97
   \   00000064   060051E3           CMP      R1,#+6
   \   00000068   57504032           SUBCC    R5,R0,#+87
   \   0000006C   EFFFFF3A           BCC      ??TRACE_GetHexa32_2
   \   00000070   ........           LDR      R0,??DataTable6_11
   \   00000074   ........           BL       printf
   \   00000078   0000A0E3           MOV      R0,#+0
   \   0000007C   F2FFFFEA           B        ??TRACE_GetHexa32_3
    298          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   2E000000           DC8      ".",0x0,0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   25630000           DC8      0x25, 0x63, 0x00, 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0A0D0000           DC8      0x0A, 0x0D, 0x00, 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   20200000           DC8      0x20, 0x20, 0x00, 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   20000000           DC8      " ",0x0,0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   ........           DC32     __iar_Stdout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   ........           DC32     __iar_Stderr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   ........           DC32     `?<Constant "%02X ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   ........           DC32     `?<Constant "0x%08X: ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   ........           DC32     `?<Constant "\\n\\rWrite a number and ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   ........           DC32     `?<Constant "\\n\\rThe number have to ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   ........           DC32     `?<Constant "\\n\\rIt is not a hexa ch...">`

   \                                 In section .rodata, align 2
   \   00000000   2E00               DC8 "."

   \                                 In section .rodata, align 4
   \   00000000   256300             DC8 "%c"
   \   00000003   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "%02X ">`:
   \   00000000   253032582000       DC8 "%02X "
   \   00000006   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0A0D00             DC8 "\012\015"
   \   00000003   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "0x%08X: ">`:
   \   00000000   307825303858       DC8 "0x%08X: "
   \              3A2000      
   \   00000009   000000             DC8 0, 0, 0
   \   0000000C   253032582530       DC8 "%02X%02X%02X%02X "
   \              325825303258
   \              253032582000
   \   0000001E   0000               DC8 0, 0
   \   00000020   2530325800         DC8 "%02X"
   \   00000025   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 2
   \   00000000   2000               DC8 " "

   \                                 In section .rodata, align 4
   \   00000000   202000             DC8 "  "
   \   00000003   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rWrite a number and ...">`:
   \   00000000   0A0D57726974       DC8 "\012\015Write a number and press ENTER or SPACE!\012\015"
   \              652061206E75
   \              6D6265722061
   \              6E6420707265
   \              737320454E54
   \              4552206F7220
   \              535041434521
   \              0A0D00      
   \   0000002D   000000             DC8 0, 0, 0
   \   00000030   0A0D27256327       DC8 "\012\015'%c' not a number!\012\015"
   \              206E6F742061
   \              206E756D6265
   \              72210A0D00  
   \   00000047   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rThe number have to ...">`:
   \   00000000   0A0D54686520       DC8 "\012\015The number have to be between %d and %d\012\015"
   \              6E756D626572
   \              206861766520
   \              746F20626520
   \              626574776565
   \              6E2025642061
   \              6E642025640A
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rIt is not a hexa ch...">`:
   \   00000000   0A0D49742069       DC8 "\012\015It is not a hexa character!\012\015"
   \              73206E6F7420
   \              612068657861
   \              206368617261
   \              63746572210A
   \              0D00        
    299          

   Maximum stack usage in bytes:

     Function               .cstack
     --------               -------
     PrintChar                   8
     TRACE_DumpFrame            24
     TRACE_DumpMemory           48
     TRACE_GetHexa32            24
     TRACE_GetInteger           24
     TRACE_GetIntegerMinMax     24
     fputc                       8
     fputs                      16
     putchar                     8


   Section sizes:

     Function/Label                           Bytes
     --------------                           -----
     fputc                                      56
     fputs                                      76
     putchar                                     8
     PrintChar                                  56
     TRACE_DumpFrame                            60
     TRACE_DumpMemory                          304
     TRACE_GetInteger                          132
     ?Subroutine0                                8
     TRACE_GetIntegerMinMax                    112
     TRACE_GetHexa32                           128
     ??DataTable6                                4
     ??DataTable6_1                              4
     ??DataTable6_2                              4
     ??DataTable6_3                              4
     ??DataTable6_4                              4
     ??DataTable6_5                              4
     ??DataTable6_6                              4
     ??DataTable6_7                              4
     ??DataTable6_8                              4
     ??DataTable6_9                              4
     ??DataTable6_10                             4
     ??DataTable6_11                             4
     ?<Constant ".">                             2
     ?<Constant "%c">                            4
     ?<Constant "%02X ">                         8
     ?<Constant "\n\r">                          4
     ?<Constant "0x%08X: ">                     40
     ?<Constant " ">                             2
     ?<Constant "  ">                            4
     ?<Constant "\n\rWrite a number and ...">   72
     ?<Constant "\n\rThe number have to ...">   44
     ?<Constant "\n\rIt is not a hexa ch...">   32

 
 212 bytes in section .rodata
 988 bytes in section .text
 
 988 bytes of CODE  memory
 212 bytes of CONST memory

Errors: none
Warnings: none
