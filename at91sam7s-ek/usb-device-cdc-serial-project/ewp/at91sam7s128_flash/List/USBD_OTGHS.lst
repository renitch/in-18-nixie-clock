###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.50.0.51878/W32 for ARM     14/Mar/2021  19:14:51 #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\Projects\in-18-nixie-clock\at91lib\usb\device\core\US #
#                    BD_OTGHS.c                                               #
#    Command line =  C:\Projects\in-18-nixie-clock\at91lib\usb\device\core\US #
#                    BD_OTGHS.c -D at91sam7s128 -D flash -D TRACE_LEVEL=3     #
#                    -lC C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-devic #
#                    e-cdc-serial-project\ewp\at91sam7s128_flash\List\        #
#                    --remarks --diag_suppress Pe826,Pe1375 -o                #
#                    C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\at91sam7s128_flash\Obj\ --debug     #
#                    --endian=little --cpu=ARM7TDMI -e --fpu=None             #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Full. #
#                    h" -I C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-dev #
#                    ice-cdc-serial-project\ewp\..\..\..\at91lib/peripherals\ #
#                     -I C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-devic #
#                    e-cdc-serial-project\ewp\..\..\..\at91lib/components\    #
#                    -I C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device #
#                    -cdc-serial-project\ewp\..\..\..\at91lib/usb/device\ -I  #
#                    C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\..\..\..\at91lib\ -I                #
#                    C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\..\..\..\external_libs\ -I          #
#                    C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\..\..\..\at91lib/boards/at91sam7s-e #
#                    k\ -I "C:\Program Files (x86)\IAR Systems\Embedded       #
#                    Workbench 5.4\arm\INC\" --interwork --cpu_mode arm -Ohz  #
#    List file    =  C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\at91sam7s128_flash\List\USBD_OTGHS. #
#                    lst                                                      #
#    Object file  =  C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\at91sam7s128_flash\Obj\USBD_OTGHS.o #
#                                                                             #
#                                                                             #
###############################################################################

C:\Projects\in-18-nixie-clock\at91lib\usb\device\core\USBD_OTGHS.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29           
     30          //------------------------------------------------------------------------------
     31          //      Headers
     32          //------------------------------------------------------------------------------
     33          
     34          #include "USBD.h"
     35          #include "USBDCallbacks.h"
     36          #include "USBDDriver.h"
     37          #include <board.h>
     38          #include <pio/pio.h>
     39          #include <utility/trace.h>
     40          #include <utility/led.h>
     41          #include <usb/common/core/USBEndpointDescriptor.h>
     42          #include <usb/common/core/USBGenericRequest.h>
     43          #include <usb/common/core/USBFeatureRequest.h>
     44          #include <pmc/pmc.h>
     45          
     46          
     47          #if defined(BOARD_USB_OTGHS)
     48          
     49          //------------------------------------------------------------------------------
     50          //         Definitions
     51          //------------------------------------------------------------------------------
     52          
     53          /// Maximum number of endpoints interrupts.
     54          #define NUM_IT_MAX       \
     55             (AT91C_BASE_OTGHS->OTGHS_IPFEATURES & AT91C_OTGHS_EPT_NBR_MAX)
     56          /// Maximum number of endpoint DMA interrupts
     57          #define NUM_IT_MAX_DMA   \
     58             ((AT91C_BASE_OTGHS->OTGHS_IPFEATURES & AT91C_OTGHS_DMA_CHANNEL_NBR)>>4)
     59          /// Bits that should be shifted to access DMA control bits.
     60          #define SHIFT_DMA        24
     61          /// Bits that should be shifted to access interrupt bits.
     62          #define SHIFT_INTERUPT   12
     63          
     64          /// Compile option, use DMA. Remove this define for not use DMA.
     65          #define DMA
     66          
     67          /// Max size of the FMA FIFO
     68          #define DMA_MAX_FIFO_SIZE    32768
     69          
     70          #define EPT_VIRTUAL_SIZE      8192
     71          
     72          //------------------------------------------------------------------------------
     73          /// \page "Endpoint states"
     74          /// This page lists the endpoint states.
     75          /// !States
     76          //  - UDP_ENDPOINT_DISABLED
     77          //  - UDP_ENDPOINT_HALTED
     78          //  - UDP_ENDPOINT_IDLE
     79          //  - UDP_ENDPOINT_SENDING
     80          //  - UDP_ENDPOINT_RECEIVING
     81          
     82          /// Endpoint states: Endpoint is disabled
     83          #define UDP_ENDPOINT_DISABLED       0
     84          /// Endpoint states: Endpoint is halted (i.e. STALLs every request)
     85          #define UDP_ENDPOINT_HALTED         1
     86          /// Endpoint states: Endpoint is idle (i.e. ready for transmission)
     87          #define UDP_ENDPOINT_IDLE           2
     88          /// Endpoint states: Endpoint is sending data
     89          #define UDP_ENDPOINT_SENDING        3
     90          /// Endpoint states: Endpoint is receiving data
     91          #define UDP_ENDPOINT_RECEIVING      4
     92          //------------------------------------------------------------------------------
     93          
     94          //------------------------------------------------------------------------------
     95          //      Structures
     96          //------------------------------------------------------------------------------
     97          
     98          /// Describes an ongoing transfer on a UDP endpoint.
     99          typedef struct
    100          {
    101              /// Pointer to a data buffer used for emission/reception.
    102              char             *pData;
    103              /// Number of bytes which have been written into the UDP internal FIFO
    104              /// buffers.
    105              volatile int     buffered;
    106              /// Number of bytes which have been sent/received.
    107              volatile int     transferred;
    108              /// Number of bytes which have not been buffered/transferred yet.
    109              volatile int     remaining;
    110              /// Optional callback to invoke when the transfer completes.
    111              volatile TransferCallback fCallback;
    112              /// Optional argument to the callback function.
    113              void             *pArgument;
    114          } Transfer;
    115          
    116          //------------------------------------------------------------------------------
    117          /// Describes the state of an endpoint of the UDP controller.
    118          //------------------------------------------------------------------------------
    119          typedef struct
    120          {
    121              /// Current endpoint state.
    122              volatile unsigned char  state;
    123              /// Current reception bank (0 or 1).
    124              unsigned char  bank;
    125              /// Maximum packet size for the endpoint.
    126              unsigned short size;
    127              /// Describes an ongoing transfer (if current state is either
    128              ///  <UDP_ENDPOINT_SENDING> or <UDP_ENDPOINT_RECEIVING>)
    129              Transfer       transfer;
    130              /// Special case for send a ZLP
    131              unsigned char  sendZLP;
    132          } Endpoint;
    133          
    134          //------------------------------------------------------------------------------
    135          //         Internal variables
    136          //------------------------------------------------------------------------------
    137          
    138          /// Holds the internal state for each endpoint of the UDP.
    139          static Endpoint      endpoints[BOARD_USB_NUMENDPOINTS];
    140          /// Device current state.
    141          static unsigned char deviceState;
    142          /// Indicates the previous device state
    143          static unsigned char previousDeviceState;
    144          
    145          /// 7.1.20 Test Mode Support
    146          /// Test codes for the USB HS test mode.
    147          static const char test_packet_buffer[] = {
    148              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,                // JKJKJKJK * 9
    149              0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,                     // JJKKJJKK * 8
    150              0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,                     // JJJJKKKK * 8
    151              0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, // JJJJJJJKKKKKKK * 8
    152              0x7F,0xBF,0xDF,0xEF,0xF7,0xFB,0xFD,                          // JJJJJJJK * 8
    153              0xFC,0x7E,0xBF,0xDF,0xEF,0xF7,0xFB,0xFD,0x7E                 // {JKKKKKKK * 10}, JK
    154          };
    155          
    156          //------------------------------------------------------------------------------
    157          //      Internal Functions
    158          //------------------------------------------------------------------------------
    159          
    160          //------------------------------------------------------------------------------
    161          /// Enable UDPHS clock
    162          //------------------------------------------------------------------------------
    163          static inline void OTGHS_EnableUsbClock( void )
    164          {
    165          
    166          }
    167          
    168          //------------------------------------------------------------------------------
    169          /// Disable UDPHS clock
    170          //------------------------------------------------------------------------------
    171          static inline void OTGHS_DisableUsbClock( void )
    172          {
    173          
    174          }
    175          
    176          //------------------------------------------------------------------------------
    177          /// Enables the transceiver of the USB controller
    178          //------------------------------------------------------------------------------
    179          static void OTGHS_EnableTransceiver(void)
    180          {
    181              AT91C_BASE_OTGHS->OTGHS_CTRL |= AT91C_OTGHS_OTGPADE;
    182          }
    183          
    184          //------------------------------------------------------------------------------
    185          /// Disables the transceiver of the USB controller associated with the specified
    186          /// USB driver
    187          //------------------------------------------------------------------------------
    188          static void OTGHS_DisableTransceiver(void)
    189          {
    190              AT91C_BASE_OTGHS->OTGHS_CTRL &= ~AT91C_OTGHS_OTGPADE;
    191          }
    192          
    193          //------------------------------------------------------------------------------
    194          /// Handles a completed transfer on the given endpoint, invoking the
    195          /// configured callback if any.
    196          /// \param bEndpoint Number of the endpoint for which the transfer has completed.
    197          /// \param bStatus   Status code returned by the transfer operation
    198          //------------------------------------------------------------------------------
    199          static void OTGHS_EndOfTransfer( unsigned char bEndpoint, char bStatus )
    200          {
    201              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
    202              Transfer *pTransfer = &(pEndpoint->transfer);
    203          
    204              // Check that endpoint was sending or receiving data
    205              if( (pEndpoint->state == UDP_ENDPOINT_RECEIVING)
    206               || (pEndpoint->state == UDP_ENDPOINT_SENDING) ) {
    207          
    208                  TRACE_DEBUG_WP("Eo");
    209                  if(pEndpoint->state == UDP_ENDPOINT_SENDING) {
    210                      pEndpoint->sendZLP = 0;
    211                  }
    212                  // Endpoint returns in Idle state
    213                  pEndpoint->state = UDP_ENDPOINT_IDLE;
    214          
    215                  // Invoke callback is present
    216                  if (pTransfer->fCallback != 0) {
    217          
    218                      ((TransferCallback) pTransfer->fCallback)
    219                          (pTransfer->pArgument,
    220                           bStatus,
    221                           pTransfer->transferred,
    222                           pTransfer->remaining + pTransfer->buffered);
    223                  }
    224                  else {
    225                      TRACE_DEBUG_WP("No callBack\n\r");
    226                  }
    227              }
    228          }
    229          
    230          //------------------------------------------------------------------------------
    231          /// Transfers a data payload from the current tranfer buffer to the endpoint
    232          /// FIFO
    233          /// \param bEndpoint Number of the endpoint which is sending data.
    234          //------------------------------------------------------------------------------
    235          static void OTGHS_WritePayload( unsigned char bEndpoint )
    236          {
    237              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
    238              Transfer *pTransfer = &(pEndpoint->transfer);
    239              char     *pFifo;
    240              signed int   size;
    241              unsigned int dCtr;
    242          
    243              pFifo = (char*)((unsigned int *)AT91C_BASE_OTGHS_EPTFIFO + (EPT_VIRTUAL_SIZE * bEndpoint));
    244          
    245              // Get the number of bytes to send
    246              size = pEndpoint->size;
    247              if (size > pTransfer->remaining) {
    248          
    249                  size = pTransfer->remaining;
    250              }
    251          
    252              // Update transfer descriptor information
    253              pTransfer->buffered += size;
    254              pTransfer->remaining -= size;
    255          
    256              // Write packet in the FIFO buffer
    257              dCtr = 0;
    258              while (size > 0) {
    259          
    260                  pFifo[dCtr] = *(pTransfer->pData);
    261                  pTransfer->pData++;
    262                  size--;
    263                  dCtr++;
    264              }
    265          }
    266          
    267          //------------------------------------------------------------------------------
    268          /// Transfers a data payload from an endpoint FIFO to the current transfer buffer
    269          /// \param bEndpoint   Endpoint number.
    270          /// \param wPacketSize Size of received data packet
    271          //------------------------------------------------------------------------------
    272          static void OTGHS_ReadPayload( unsigned char bEndpoint, int wPacketSize )
    273          {
    274              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
    275              Transfer *pTransfer = &(pEndpoint->transfer);
    276              char     *pFifo;
    277              unsigned char dBytes=0;
    278          
    279              pFifo = (char*)((unsigned int *)AT91C_BASE_OTGHS_EPTFIFO + (EPT_VIRTUAL_SIZE * bEndpoint));
    280          
    281              // Check that the requested size is not bigger than the remaining transfer
    282              if (wPacketSize > pTransfer->remaining) {
    283          
    284                  pTransfer->buffered += wPacketSize - pTransfer->remaining;
    285                  wPacketSize = pTransfer->remaining;
    286              }
    287          
    288              // Update transfer descriptor information
    289              pTransfer->remaining -= wPacketSize;
    290              pTransfer->transferred += wPacketSize;
    291          
    292              // Retrieve packet
    293              while (wPacketSize > 0) {
    294          
    295                  *(pTransfer->pData) = pFifo[dBytes];
    296                  pTransfer->pData++;
    297                  wPacketSize--;
    298                  dBytes++;
    299              }
    300          }
    301          
    302          //------------------------------------------------------------------------------
    303          /// Received SETUP packet from endpoint 0 FIFO
    304          /// \param pRequest Generic USB SETUP request sent over Control endpoints
    305          //------------------------------------------------------------------------------
    306          static void OTGHS_ReadRequest( USBGenericRequest *pRequest )
    307          {
    308              unsigned int *pData = (unsigned int *)pRequest;
    309              unsigned int fifo;
    310          
    311              fifo = (AT91C_BASE_OTGHS_EPTFIFO->OTGHS_READEPT0[0]);
    312              *pData = fifo;
    313              fifo = (AT91C_BASE_OTGHS_EPTFIFO->OTGHS_READEPT0[0]);
    314              pData++;
    315              *pData = fifo;
    316              //TRACE_ERROR("SETUP: 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n\r", pData[0],pData[1],pData[2],pData[3],pData[4],pData[5],pData[6],pData[7]);
    317          }
    318          
    319          //------------------------------------------------------------------------------
    320          /// Reset all endpoint transfer descriptors
    321          //------------------------------------------------------------------------------
    322          static void OTGHS_ResetEndpoints( void )
    323          {
    324              Endpoint *pEndpoint;
    325              Transfer *pTransfer;
    326          
    327              unsigned char bEndpoint;
    328          
    329              // Reset the transfer descriptor of every endpoint
    330              for( bEndpoint = 0; bEndpoint < BOARD_USB_NUMENDPOINTS; bEndpoint++ ) {
    331          
    332                  pEndpoint = &(endpoints[bEndpoint]);
    333                  pTransfer = &(pEndpoint->transfer);
    334          
    335                  // Reset endpoint transfer descriptor
    336                  pTransfer->pData = 0;
    337                  pTransfer->transferred = -1;
    338                  pTransfer->buffered = -1;
    339                  pTransfer->remaining = -1;
    340                  pTransfer->fCallback = 0;
    341                  pTransfer->pArgument = 0;
    342          
    343                  // Reset endpoint state
    344                  pEndpoint->bank = 0;
    345                  pEndpoint->state = UDP_ENDPOINT_DISABLED;
    346                  // Reset ZLP
    347                  pEndpoint->sendZLP = 0;
    348              }
    349          }
    350          
    351          
    352          //------------------------------------------------------------------------------
    353          /// Disable all endpoints (except control endpoint 0), aborting current 
    354          /// transfers if necessary
    355          //------------------------------------------------------------------------------
    356          static void OTGHS_DisableEndpoints( void )
    357          {
    358              unsigned char bEndpoint;
    359          
    360              // Disable each endpoint, terminating any pending transfer
    361          
    362          
    363              // Control endpoint 0 is not disabled
    364              for( bEndpoint = 1; bEndpoint < BOARD_USB_NUMENDPOINTS; bEndpoint++ ) {
    365          
    366                  OTGHS_EndOfTransfer( bEndpoint, USBD_STATUS_ABORTED );
    367                  endpoints[bEndpoint].state = UDP_ENDPOINT_DISABLED;
    368              }
    369          }
    370          
    371          
    372          //------------------------------------------------------------------------------
    373          /// Endpoint interrupt handler.
    374          /// Handle IN/OUT transfers, received SETUP packets and STALLing
    375          /// \param bEndpoint Index of endpoint
    376          //------------------------------------------------------------------------------
    377          static void OTGHS_EndpointHandler( unsigned char bEndpoint )
    378          {
    379              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
    380              Transfer *pTransfer = &(pEndpoint->transfer);
    381              unsigned int   status = AT91C_BASE_OTGHS->OTGHS_DEVEPTISR[bEndpoint];
    382              unsigned short wPacketSize;
    383              USBGenericRequest request;
    384          
    385              TRACE_DEBUG_WP("E%d ", bEndpoint);
    386              TRACE_DEBUG_WP("st:0x%X ", status);
    387          
    388              // Handle interrupts
    389              // IN packet sent
    390              if((AT91C_BASE_OTGHS->OTGHS_DEVEPTIMR[bEndpoint] & AT91C_OTGHS_TXINI)
    391              && (status & AT91C_OTGHS_TXINI )) {
    392          
    393                  TRACE_DEBUG_WP("Wr ");
    394          
    395                  // Check that endpoint was in Sending state
    396                  if( pEndpoint->state == UDP_ENDPOINT_SENDING ) {
    397          
    398                      if (pTransfer->buffered > 0) {
    399                          pTransfer->transferred += pTransfer->buffered;
    400                          pTransfer->buffered = 0;
    401                      }
    402          
    403                      if(  ((pTransfer->buffered)==0)
    404                         &&((pTransfer->transferred)==0)
    405                         &&((pTransfer->remaining)==0)
    406                         &&(pEndpoint->sendZLP == 0)) {
    407                          pEndpoint->sendZLP = 1;
    408                      }
    409          
    410                      // End of transfer ?
    411                      if( (pTransfer->remaining > 0)
    412                        ||(pEndpoint->sendZLP == 1)) {
    413          
    414                          pEndpoint->sendZLP = 2;
    415                          // Transfer remaining data
    416                          TRACE_DEBUG_WP(" %d ", pEndpoint->size);
    417                          // Send next packet
    418                          OTGHS_WritePayload(bEndpoint);
    419          
    420                          // Send Token IN
    421                          AT91C_BASE_OTGHS->OTGHS_DEVEPTICR[bEndpoint] = AT91C_OTGHS_TXINI;
    422                          // For a non-control endpoint, the FIFOCON bit must be cleared
    423                          // to start the transfer
    424                          if ((AT91C_OTGHS_EPT_TYPE & AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[bEndpoint])
    425                                                       != AT91C_OTGHS_EPT_TYPE_CTL_EPT) {
    426                              // Send IN
    427                              AT91C_BASE_OTGHS->OTGHS_DEVEPTIDR[bEndpoint] = AT91C_OTGHS_FIFOCON;
    428                          }
    429                      }
    430                      else {
    431          
    432                          TRACE_DEBUG_WP("\n\r0pTransfer->buffered %d \n\r", pTransfer->buffered);
    433                          TRACE_DEBUG_WP("0pTransfer->transferred %d \n\r", pTransfer->transferred);
    434                          TRACE_DEBUG_WP("0pTransfer->remaining %d \n\r", pTransfer->remaining);
    435          
    436                          TRACE_DEBUG_WP(" %d ", pTransfer->transferred);
    437          
    438                          // Disable interrupt if this is not a control endpoint
    439                          if ((AT91C_OTGHS_EPT_TYPE & AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[bEndpoint])
    440                              != AT91C_OTGHS_EPT_TYPE_CTL_EPT) {
    441          
    442                              AT91C_BASE_OTGHS->OTGHS_DEVIDR = 1<<SHIFT_INTERUPT<<bEndpoint;
    443          
    444                          }
    445                          AT91C_BASE_OTGHS->OTGHS_DEVEPTIDR[bEndpoint] = AT91C_OTGHS_TXINI;
    446                          OTGHS_EndOfTransfer(bEndpoint, USBD_STATUS_SUCCESS);
    447                          pEndpoint->sendZLP = 0;
    448                      }
    449                  }
    450                  else {
    451                        TRACE_DEBUG("Error Wr %d", pEndpoint->sendZLP);
    452                  }
    453              }
    454          
    455              // OUT packet received
    456              if( AT91C_OTGHS_RXOUT == (status & AT91C_OTGHS_RXOUT) ) {
    457          
    458                  // Check that the endpoint is in Receiving state
    459                  if (pEndpoint->state != UDP_ENDPOINT_RECEIVING) {
    460          
    461                      // Check if an ACK has been received on a Control endpoint
    462                      if( ((AT91C_OTGHS_EPT_TYPE & AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[bEndpoint])
    463                            == AT91C_OTGHS_EPT_TYPE_CTL_EPT)
    464                       && (0 == (status & AT91C_OTGHS_BYCT)) ) {
    465          
    466                          // Control endpoint, 0 bytes received
    467                          // Acknowledge the data and finish the current transfer
    468                          TRACE_DEBUG_WP("Ack ");
    469                          AT91C_BASE_OTGHS->OTGHS_DEVEPTICR[bEndpoint] = AT91C_OTGHS_RXOUT;
    470                          AT91C_BASE_OTGHS->OTGHS_DEVEPTIDR[bEndpoint] = AT91C_OTGHS_RXOUT;
    471                          //OTGHS_EndOfTransfer(bEndpoint, USBD_STATUS_SUCCESS);
    472                      }
    473                      // Check if the data has been STALLed
    474                      else if( AT91C_OTGHS_STALL == (status & AT91C_OTGHS_STALL)) {
    475          
    476                          // Discard STALLed data
    477                          TRACE_DEBUG_WP("Discard ");
    478                          AT91C_BASE_OTGHS->OTGHS_DEVEPTICR[bEndpoint] = AT91C_OTGHS_RXOUT;
    479                      }
    480                      else {
    481                          // NAK the data
    482                          TRACE_DEBUG_WP("Nak ");
    483                          AT91C_BASE_OTGHS->OTGHS_DEVIDR = 1<<SHIFT_INTERUPT<<bEndpoint;
    484                      }
    485                  }
    486                  else {
    487          
    488                      // Endpoint is in Read state
    489                      // Retrieve data and store it into the current transfer buffer
    490                      wPacketSize = (unsigned short) ((status >> 20) & 0x7FF);
    491          
    492                      //TRACE_ERROR_WP("out:%d ", wPacketSize);
    493                      OTGHS_ReadPayload(bEndpoint, wPacketSize);
    494                      AT91C_BASE_OTGHS->OTGHS_DEVEPTICR[bEndpoint] = AT91C_OTGHS_RXOUT;
    495                      if((AT91C_OTGHS_EPT_TYPE & AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[bEndpoint])
    496                            != AT91C_OTGHS_EPT_TYPE_CTL_EPT) {
    497                          AT91C_BASE_OTGHS->OTGHS_DEVEPTIDR[bEndpoint] = AT91C_OTGHS_FIFOCON;
    498                      }
    499          
    500                      // Check if the transfer is finished
    501                      if ((pTransfer->remaining == 0) || (wPacketSize < pEndpoint->size)) {
    502          
    503                          AT91C_BASE_OTGHS->OTGHS_DEVEPTIDR[bEndpoint] = AT91C_OTGHS_RXOUT;
    504          
    505                          // Disable interrupt if this is not a control endpoint
    506                          if ((AT91C_OTGHS_EPT_TYPE & AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[bEndpoint])
    507                              != AT91C_OTGHS_EPT_TYPE_CTL_EPT) {
    508          
    509                              AT91C_BASE_OTGHS->OTGHS_DEVIDR = 1<<SHIFT_INTERUPT<<bEndpoint;
    510                          }
    511                          //TRACE_ERROR_WP("Y ");
    512                          OTGHS_EndOfTransfer(bEndpoint, USBD_STATUS_SUCCESS);
    513                      }
    514                  }
    515              }
    516          
    517              // STALL sent
    518              if( AT91C_OTGHS_STALL == (status & AT91C_OTGHS_STALL) ) {
    519          
    520                  TRACE_WARNING( "Sta 0x%X [%d] ", status, bEndpoint);
    521          
    522                  // Acknowledge the stall flag
    523                  AT91C_BASE_OTGHS->OTGHS_DEVEPTICR[bEndpoint] = AT91C_OTGHS_STALL;
    524          
    525                  // If the endpoint is not halted, clear the STALL condition
    526                  if (pEndpoint->state != UDP_ENDPOINT_HALTED) {
    527          
    528                      TRACE_WARNING("_ " );
    529                      AT91C_BASE_OTGHS->OTGHS_DEVEPTIDR[bEndpoint] = AT91C_OTGHS_STALLRQ;
    530                  }
    531              }
    532          
    533              // SETUP packet received
    534              if( AT91C_OTGHS_RXSTP == (status & AT91C_OTGHS_RXSTP) )  {
    535          
    536                  TRACE_DEBUG_WP("Stp ");
    537          
    538                  // If a transfer was pending, complete it
    539                  // Handles the case where during the status phase of a control write
    540                  // transfer, the host receives the device ZLP and ack it, but the ack
    541                  // is not received by the device
    542                  if ((pEndpoint->state == UDP_ENDPOINT_RECEIVING)
    543                      || (pEndpoint->state == UDP_ENDPOINT_SENDING)) {
    544          
    545                      OTGHS_EndOfTransfer(bEndpoint, USBD_STATUS_SUCCESS);
    546                  }
    547          
    548                  // Copy the setup packet
    549                  OTGHS_ReadRequest(&request);
    550          
    551                  // Acknowledge setup packet
    552                  AT91C_BASE_OTGHS->OTGHS_DEVEPTICR[bEndpoint] = AT91C_OTGHS_RXSTP;
    553          
    554                  // Forward the request to the upper layer
    555                  USBDCallbacks_RequestReceived(&request);
    556              }
    557          }
    558          
    559          //------------------------------------------------------------------------------
    560          //      Interrupt service routine
    561          //------------------------------------------------------------------------------
    562          #ifdef DMA
    563          //----------------------------------------------------------------------------
    564          /// Endpoint DMA interrupt handler.
    565          /// This function (ISR) handles dma interrupts
    566          /// \param bEndpoint Index of endpoint
    567          //----------------------------------------------------------------------------
    568          static void OTGHS_DmaHandler( unsigned char bEndpoint )
    569          {
    570              Endpoint     *pEndpoint = &(endpoints[bEndpoint]);
    571              Transfer     *pTransfer = &(pEndpoint->transfer);
    572              int           justTransferred;
    573              unsigned int  status;
    574              unsigned char result = USBD_STATUS_SUCCESS;
    575          
    576              status = AT91C_BASE_OTGHS->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMASTATUS;
    577              TRACE_DEBUG_WP("Dma Ept%d ", bEndpoint);
    578          
    579              // Disable DMA interrupt to avoid receiving 2 interrupts (B_EN and TR_EN)
    580              AT91C_BASE_OTGHS->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMACONTROL &=
    581                  ~(AT91C_OTGHS_END_TR_EN | AT91C_OTGHS_END_B_EN);
    582          
    583              AT91C_BASE_OTGHS->OTGHS_DEVIDR = (1<<SHIFT_DMA<<bEndpoint);
    584          
    585              if( AT91C_OTGHS_END_BF_ST == (status & AT91C_OTGHS_END_BF_ST) ) {
    586          
    587                  TRACE_DEBUG_WP("EndBuffer ");
    588          
    589                  // BUFF_COUNT holds the number of untransmitted bytes.
    590                  // BUFF_COUNT is equal to zero in case of good transfer
    591                  justTransferred = pTransfer->buffered
    592                                           - ((status & AT91C_OTGHS_BUFF_COUNT) >> 16);
    593                  pTransfer->transferred += justTransferred;
    594          
    595                  pTransfer->buffered = ((status & AT91C_OTGHS_BUFF_COUNT) >> 16);
    596          
    597                  pTransfer->remaining -= justTransferred;
    598          
    599                  TRACE_DEBUG_WP("\n\r1pTransfer->buffered %d \n\r", pTransfer->buffered);
    600                  TRACE_DEBUG_WP("1pTransfer->transferred %d \n\r", pTransfer->transferred);
    601                  TRACE_DEBUG_WP("1pTransfer->remaining %d \n\r", pTransfer->remaining);
    602          
    603                  if( (pTransfer->remaining + pTransfer->buffered) > 0 ) {
    604          
    605                      // Prepare an other transfer
    606                      if( pTransfer->remaining > DMA_MAX_FIFO_SIZE ) {
    607          
    608                          pTransfer->buffered = DMA_MAX_FIFO_SIZE;    
    609                      }
    610                      else {
    611                          pTransfer->buffered = pTransfer->remaining;
    612                      }
    613          
    614                      AT91C_BASE_OTGHS->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMAADDRESS = 
    615                          (unsigned int)((pTransfer->pData) + (pTransfer->transferred));
    616          
    617                      // Clear unwanted interrupts
    618                      AT91C_BASE_OTGHS->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMASTATUS;
    619          
    620                      // Enable DMA endpoint interrupt
    621                      AT91C_BASE_OTGHS->OTGHS_DEVIER = (1 << SHIFT_DMA << bEndpoint);
    622                      // DMA config for receive the good size of buffer, or an error buffer
    623          
    624                      AT91C_BASE_OTGHS->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMACONTROL = 0; // raz
    625                      AT91C_BASE_OTGHS->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMACONTROL =
    626                                               ( ((pTransfer->buffered << 16) & AT91C_OTGHS_BUFF_COUNT)
    627                                                 | AT91C_OTGHS_END_TR_EN
    628                                                 | AT91C_OTGHS_END_TR_IT
    629                                                 | AT91C_OTGHS_END_B_EN
    630                                                 | AT91C_OTGHS_END_BUFFIT
    631                                                 | AT91C_OTGHS_CHANN_ENB );
    632                  }
    633              }
    634              else if( AT91C_OTGHS_END_TR_ST == (status & AT91C_OTGHS_END_TR_ST) ) {
    635          
    636                  TRACE_DEBUG_WP("EndTransf ");
    637          
    638                  pTransfer->transferred = pTransfer->buffered
    639                                           - ((status & AT91C_OTGHS_BUFF_COUNT) >> 16);
    640                  pTransfer->remaining = 0;
    641                  TRACE_DEBUG_WP("\n\r0pTransfer->buffered %d \n\r", pTransfer->buffered);
    642                  TRACE_DEBUG_WP("0pTransfer->transferred %d \n\r", pTransfer->transferred);
    643                  TRACE_DEBUG_WP("0pTransfer->remaining %d \n\r", pTransfer->remaining);
    644              }
    645              else {
    646          
    647                  TRACE_ERROR("OTGHS_DmaHandler: Error (0x%08X)\n\r", status);
    648                  result = USBD_STATUS_ABORTED;
    649              }
    650          
    651              // Invoke callback
    652              if( pTransfer->remaining == 0 ) {
    653          
    654                  TRACE_DEBUG_WP("EOT ");
    655                  OTGHS_EndOfTransfer(bEndpoint, result);
    656              }
    657          }
    658          #endif
    659          
    660          //------------------------------------------------------------------------------
    661          //      Exported functions
    662          //------------------------------------------------------------------------------
    663          
    664          //------------------------------------------------------------------------------
    665          /// USB interrupt handler
    666          /// Manages device resume, suspend, end of bus reset. 
    667          /// Forwards endpoint interrupts to the appropriate handler.
    668          //------------------------------------------------------------------------------
    669          void UDPD_IrqHandler(void)
    670          {
    671              unsigned int  status;
    672              unsigned char numIT;
    673          
    674              if (deviceState >= USBD_STATE_POWERED) {
    675          
    676                  LED_Set(USBD_LEDUSB);
    677              }
    678          
    679              // Get interrupts status
    680              status = AT91C_BASE_OTGHS->OTGHS_SR & AT91C_BASE_OTGHS->OTGHS_CTRL & 0xFF;
    681              while (status != 0) {
    682                  //TRACE_ERROR_WP("~");
    683                  if((status&AT91C_OTGHS_VBUSTI)==AT91C_OTGHS_VBUSTI) {
    684                      TRACE_DEBUG_WP("__VBus\n\r");
    685          
    686                      USBD_Connect();
    687          
    688                      // Acknowledge the interrupt
    689                      AT91C_BASE_OTGHS->OTGHS_SCR = AT91C_OTGHS_VBUSTI;
    690                  }
    691          
    692                  // Don't treat others interrupt for this time
    693                  AT91C_BASE_OTGHS->OTGHS_SCR = AT91C_OTGHS_IDT    | AT91C_OTGHS_SRP 
    694                                        | AT91C_OTGHS_VBERR  | AT91C_OTGHS_BCERR
    695                                        | AT91C_OTGHS_ROLEEX | AT91C_OTGHS_HNPERR
    696                                        | AT91C_OTGHS_STO;
    697          
    698                  AT91C_BASE_OTGHS->OTGHS_CTRL &= ~(AT91C_OTGHS_IDT); 
    699              
    700                  status = AT91C_BASE_OTGHS->OTGHS_SR & AT91C_BASE_OTGHS->OTGHS_CTRL & 0xFF;
    701              }
    702          
    703          
    704              // Get OTG Device interrupts status
    705              status = AT91C_BASE_OTGHS->OTGHS_DEVISR & AT91C_BASE_OTGHS->OTGHS_DEVIMR;
    706              while (status != 0) {
    707                  //TRACE_ERROR_WP("=");
    708                  // Start Of Frame (SOF)
    709                  if((status&AT91C_OTGHS_SOF)==AT91C_OTGHS_SOF) {
    710                      TRACE_DEBUG_WP("SOF ");
    711          
    712                      // Invoke the SOF callback
    713                      //USB_StartOfFrameCallback();
    714          
    715                      // Acknowledge interrupt
    716                      AT91C_BASE_OTGHS->OTGHS_DEVICR = AT91C_OTGHS_SOF;
    717                      status &= ~AT91C_OTGHS_SOF;
    718                  }
    719          
    720                  // Suspend
    721                  // This interrupt is always treated last (hence the '==')
    722                  else if (status == AT91C_OTGHS_SUSP) {
    723          
    724                      TRACE_DEBUG_WP("S");
    725          
    726                      // The device enters the Suspended state
    727                      //      MCK + UDPCK must be off
    728                      //      Pull-Up must be connected
    729                      //      Transceiver must be disabled
    730          
    731                      LED_Clear(USBD_LEDUSB);
    732          
    733                      // Enable wakeup
    734                      AT91C_BASE_OTGHS->OTGHS_DEVIER = AT91C_OTGHS_EORST | AT91C_OTGHS_WAKEUP | AT91C_OTGHS_EORSM;
    735          
    736                      // Acknowledge interrupt
    737                      AT91C_BASE_OTGHS->OTGHS_DEVICR = AT91C_OTGHS_SUSP;
    738                      previousDeviceState = deviceState;
    739                      deviceState = USBD_STATE_SUSPENDED;
    740                      OTGHS_DisableTransceiver();
    741                      OTGHS_DisableUsbClock();
    742                      // Invoke the Suspend callback
    743                      USBDCallbacks_Suspended();
    744                  }
    745          
    746                  // Resume
    747                  else if( ((status & AT91C_OTGHS_WAKEUP) != 0)    // line activity
    748                        || ((status & AT91C_OTGHS_EORSM) != 0))  { // pc wakeup
    749          
    750                      // Invoke the Resume callback
    751                      USBDCallbacks_Resumed();
    752          
    753                      TRACE_DEBUG_WP("R");
    754          
    755                      OTGHS_EnableUsbClock();
    756                      OTGHS_EnableTransceiver();
    757          
    758                      // The device enters Configured state
    759                      //      MCK + UDPCK must be on
    760                      //      Pull-Up must be connected
    761                      //      Transceiver must be enabled
    762          
    763                      deviceState = previousDeviceState;
    764          
    765                      AT91C_BASE_OTGHS->OTGHS_DEVICR = 
    766                          (AT91C_OTGHS_WAKEUP | AT91C_OTGHS_EORSM | AT91C_OTGHS_SUSP);
    767                      AT91C_BASE_OTGHS->OTGHS_DEVIER = (AT91C_OTGHS_EORST | AT91C_OTGHS_SUSP);
    768                      AT91C_BASE_OTGHS->OTGHS_DEVICR = (AT91C_OTGHS_WAKEUP | AT91C_OTGHS_EORSM);
    769                      AT91C_BASE_OTGHS->OTGHS_DEVIDR = AT91C_OTGHS_WAKEUP;
    770          
    771                  }
    772          
    773                  // End of bus reset
    774                  else if ((status & AT91C_OTGHS_EORST) == AT91C_OTGHS_EORST) {
    775          
    776                      TRACE_DEBUG_WP("EoB ");
    777          
    778                      // The device enters the Default state
    779                      deviceState = USBD_STATE_DEFAULT;
    780                      //      MCK + UDPCK are already enabled
    781                      //      Pull-Up is already connected
    782                      //      Transceiver must be enabled
    783                      //      Endpoint 0 must be enabled
    784          
    785                      OTGHS_EnableTransceiver();
    786                      USBDDriver_clearOTGFeatures();
    787          
    788                      // The device leaves the Address & Configured states
    789                      OTGHS_ResetEndpoints();
    790                      OTGHS_DisableEndpoints();
    791                      USBD_ConfigureEndpoint(0);
    792          
    793                      // Flush and enable the Suspend interrupt
    794                      AT91C_BASE_OTGHS->OTGHS_DEVICR = AT91C_OTGHS_WAKEUP | AT91C_OTGHS_SUSP;
    795          
    796                      //// Enable the Start Of Frame (SOF) interrupt if needed
    797                      //if (pCallbacks->startOfFrame != 0)
    798                      //{
    799                      //    AT91C_BASE_OTGHS->OTGHS_DEVIER |= AT91C_OTGHS_SOF;
    800                      //}
    801          
    802                      // Invoke the Reset callback
    803                      USBDCallbacks_Reset();
    804          
    805                      // Acknowledge end of bus reset interrupt
    806                      AT91C_BASE_OTGHS->OTGHS_DEVICR = AT91C_OTGHS_EORST;
    807                  }
    808          
    809                  // Handle upstream resume interrupt
    810                  else if (status & AT91C_OTGHS_UPRSM) {
    811          
    812                      TRACE_DEBUG_WP("ExtRes ");
    813          
    814                      // - Acknowledge the IT
    815                      AT91C_BASE_OTGHS->OTGHS_DEVICR = AT91C_OTGHS_UPRSM;
    816                  }
    817          
    818                  // Endpoint interrupts
    819                  else {
    820          #ifndef DMA
    821          
    822                      // Handle endpoint interrupts
    823                      for (numIT = 0; numIT < NUM_IT_MAX; numIT++) {
    824          
    825                          if ((status & (1 << SHIFT_INTERUPT << numIT)) != 0) {
    826          
    827                              OTGHS_EndpointHandler(numIT);
    828                          }
    829                      }
    830          #else
    831                      // Handle endpoint control interrupt
    832                      if ((status & (1 << SHIFT_INTERUPT << 0)) != 0) {
    833          
    834                          OTGHS_EndpointHandler( 0 );
    835                      }
    836                      else {
    837          
    838                          numIT = 1;
    839                          while((status&(0x7E<<SHIFT_DMA)) != 0) {
    840          
    841                              // Check if endpoint has a pending interrupt
    842                              if ((status & (1 << SHIFT_DMA << numIT)) != 0) {
    843          
    844                                  OTGHS_DmaHandler(numIT);
    845                                  status &= ~(1 << SHIFT_DMA << numIT);
    846                                  if (status != 0) {
    847          
    848                                      TRACE_INFO_WP("\n\r  - ");
    849                                  }
    850                              }
    851                              numIT++;
    852                          }
    853                      }
    854          #endif
    855                  }
    856          
    857                  // Retrieve new interrupt status
    858                  status = AT91C_BASE_OTGHS->OTGHS_DEVISR & AT91C_BASE_OTGHS->OTGHS_DEVIMR;
    859          
    860                  TRACE_DEBUG_WP("\n\r");
    861          
    862                  if (status != 0) {
    863          
    864                      TRACE_DEBUG_WP("  - ");
    865                  }
    866              }
    867          
    868              if (deviceState >= USBD_STATE_POWERED) {
    869          
    870                  LED_Clear(USBD_LEDUSB);
    871              }
    872          }
    873          
    874          //------------------------------------------------------------------------------
    875          /// Configure an endpoint with the provided endpoint descriptor
    876          /// \param pDdescriptor Pointer to the endpoint descriptor
    877          //------------------------------------------------------------------------------
    878          void USBD_ConfigureEndpoint(const USBEndpointDescriptor *pDescriptor)
    879          
    880          {
    881              Endpoint *pEndpoint;
    882              unsigned char bEndpoint;
    883              unsigned char bType;
    884              unsigned char bEndpointDir;
    885              unsigned char bSizeEpt = 0;
    886          
    887              // NULL descriptor -> Control endpoint 0
    888              if (pDescriptor == 0) {
    889          
    890                  bEndpoint = 0;
    891                  pEndpoint = &(endpoints[bEndpoint]);
    892                  bType = USBEndpointDescriptor_CONTROL;
    893                  bEndpointDir = 0;
    894                  pEndpoint->size = BOARD_USB_ENDPOINTS_MAXPACKETSIZE(0);
    895                  pEndpoint->bank = BOARD_USB_ENDPOINTS_BANKS(0);
    896              }
    897              else {
    898          
    899                  // The endpoint number
    900                  bEndpoint = USBEndpointDescriptor_GetNumber(pDescriptor);
    901                  pEndpoint = &(endpoints[bEndpoint]);
    902                  // Transfer type: Control, Isochronous, Bulk, Interrupt
    903                  bType = USBEndpointDescriptor_GetType(pDescriptor);
    904                  // Direction, ignored for control endpoints
    905                  bEndpointDir = USBEndpointDescriptor_GetDirection(pDescriptor);
    906                  pEndpoint->size = USBEndpointDescriptor_GetMaxPacketSize(pDescriptor);
    907                  pEndpoint->bank = BOARD_USB_ENDPOINTS_BANKS(bEndpoint);
    908              }
    909          
    910              // Abort the current transfer is the endpoint was configured and in
    911              // Write or Read state
    912              if( (pEndpoint->state == UDP_ENDPOINT_RECEIVING)
    913               || (pEndpoint->state == UDP_ENDPOINT_SENDING) ) {
    914          
    915                  OTGHS_EndOfTransfer(bEndpoint, USBD_STATUS_RESET);
    916              }
    917              pEndpoint->state = UDP_ENDPOINT_IDLE;
    918          
    919              // Disable endpoint
    920              AT91C_BASE_OTGHS->OTGHS_DEVEPTIDR[bEndpoint] = AT91C_OTGHS_TXINI    
    921                                                           | AT91C_OTGHS_RXOUT    
    922                                                           | AT91C_OTGHS_RXSTP    
    923                                                           | AT91C_OTGHS_NAKOUT   
    924                                                           | AT91C_OTGHS_NAKIN    
    925                                                           | AT91C_OTGHS_OVERFL   
    926                                                           | AT91C_OTGHS_STALL    
    927                                                           | AT91C_OTGHS_SHRTPACK 
    928                                                           | AT91C_OTGHS_MADATA   
    929                                                           | AT91C_OTGHS_DATAX    
    930                                                           | AT91C_OTGHS_ERRTRANS 
    931                                                           | AT91C_OTGHS_NBUSYBK  
    932                                                           | AT91C_OTGHS_FIFOCON  
    933                                                           | AT91C_OTGHS_EPDISHDMA
    934                                                           | AT91C_OTGHS_NYETDIS  
    935                                                           | AT91C_OTGHS_STALLRQ;
    936          
    937              // Reset Endpoint Fifos
    938              AT91C_BASE_OTGHS->OTGHS_DEVEPT |= (1<<bEndpoint<<16);
    939              AT91C_BASE_OTGHS->OTGHS_DEVEPT &= ~(1<<bEndpoint<<16);
    940          
    941              // Configure endpoint
    942              if( pEndpoint->size <= 8 )  {
    943                  bSizeEpt = 0;
    944              } 
    945              else if ( pEndpoint->size <= 16 ) {
    946                  bSizeEpt = 1;
    947              }
    948              else if ( pEndpoint->size <= 32 ) {
    949                  bSizeEpt = 2;
    950              }
    951              else if ( pEndpoint->size <= 64 ) {
    952                  bSizeEpt = 3;
    953              }
    954              else if ( pEndpoint->size <= 128 ) {
    955                  bSizeEpt = 4;
    956              }
    957              else if ( pEndpoint->size <= 256 ) {
    958                  bSizeEpt = 5;
    959              }
    960              else if ( pEndpoint->size <= 512 )  {
    961                  bSizeEpt = 6;
    962              }
    963              else if ( pEndpoint->size <= 1024 ) {
    964                  bSizeEpt = 7;
    965              } //else {
    966              //  sizeEpt = 0; // control endpoint
    967              //}
    968          
    969              // Enable endpoint
    970              AT91C_BASE_OTGHS->OTGHS_DEVEPT |= (1<<bEndpoint);
    971          
    972              // Configure endpoint
    973              if (bType == USBEndpointDescriptor_CONTROL) {
    974          
    975                  // Enable endpoint IT for control endpoint
    976                  AT91C_BASE_OTGHS->OTGHS_DEVIER = 1<<SHIFT_INTERUPT<<bEndpoint;
    977              }
    978          
    979              AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[bEndpoint] = (bSizeEpt << 4) 
    980                                                           | (bEndpointDir << 8) 
    981                                                           | (bType << 11) 
    982                                                           | (((pEndpoint->bank)-1) << 2);
    983          
    984              if (bType == USBEndpointDescriptor_CONTROL) {
    985          
    986                  AT91C_BASE_OTGHS->OTGHS_DEVEPTIER[bEndpoint] = AT91C_OTGHS_RXSTP;
    987              }
    988          #ifdef DMA
    989              else {
    990                  AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[bEndpoint] |= AT91C_OTGHS_AUTOSW;
    991              }
    992          #endif
    993          
    994              AT91C_BASE_OTGHS->OTGHS_DEVEPTIDR[bEndpoint] = AT91C_OTGHS_NYETDIS;// with nyet
    995              //AT91C_BASE_OTGHS->OTGHS_DEVEPTIER[bEndpoint] = AT91C_OTGHS_NYETDIS;  // without nyet
    996          
    997              // Check if the configuration is ok
    998              AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[bEndpoint] |= AT91C_OTGHS_ALLOC;
    999              if((AT91C_BASE_OTGHS->OTGHS_DEVEPTISR[bEndpoint]&AT91C_OTGHS_CFGOK)==0) {
   1000          
   1001                  TRACE_ERROR("PB bEndpoint: 0x%X\n\r", bEndpoint);
   1002                  TRACE_ERROR("PB bSizeEpt: 0x%X\n\r", bSizeEpt);
   1003                  TRACE_ERROR("PB bEndpointDir: 0x%X\n\r", bEndpointDir);
   1004                  TRACE_ERROR("PB bType: 0x%X\n\r", bType);
   1005                  TRACE_ERROR("PB pEndpoint->bank: 0x%X\n\r", pEndpoint->bank);
   1006                  TRACE_ERROR("PB OTGHS_EPTCFG: 0x%X\n\r", AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[bEndpoint]);
   1007                  for(;;);
   1008              }
   1009          }
   1010          
   1011          //------------------------------------------------------------------------------
   1012          /// Sends data through an USB endpoint (IN)
   1013          /// Sets up the transfer descriptor, write one or two data payloads
   1014          /// (depending on the number of FIFO banks for the endpoint) and then
   1015          /// starts the actual transfer. The operation is complete when all
   1016          /// the data has been sent.
   1017          /// \param bEndpoint Index of endpoint
   1018          /// \param *pData  Data to be written
   1019          /// \param dLength Data length to be send
   1020          /// \param fCallback  Callback to be call after the success command
   1021          /// \param *pArgument Callback argument
   1022          /// \return USBD_STATUS_LOCKED or USBD_STATUS_SUCCESS
   1023          //------------------------------------------------------------------------------
   1024          char USBD_Write( unsigned char    bEndpoint,
   1025                           const void       *pData,
   1026                           unsigned int     dLength,
   1027                           TransferCallback fCallback,
   1028                           void             *pArgument )
   1029          {
   1030              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   1031              Transfer *pTransfer = &(pEndpoint->transfer);
   1032          //unsigned char i;
   1033          //unsigned char * data;
   1034          
   1035              // Return if the endpoint is not in IDLE state
   1036              if (pEndpoint->state != UDP_ENDPOINT_IDLE)  {
   1037          
   1038                  return USBD_STATUS_LOCKED;
   1039              }
   1040          
   1041              TRACE_DEBUG_WP("Write%d(%d) ", bEndpoint, dLength);
   1042              pEndpoint->sendZLP = 0;
   1043              // Setup the transfer descriptor
   1044              pTransfer->pData = (void *) pData;
   1045              pTransfer->remaining = dLength;
   1046              pTransfer->buffered = 0;
   1047              pTransfer->transferred = 0;
   1048              pTransfer->fCallback = fCallback;
   1049              pTransfer->pArgument = pArgument;
   1050          
   1051              // Send one packet
   1052              pEndpoint->state = UDP_ENDPOINT_SENDING;
   1053          
   1054          #ifdef DMA
   1055              // Test if endpoint type control
   1056              if (AT91C_OTGHS_EPT_TYPE_CTL_EPT == (AT91C_OTGHS_EPT_TYPE & AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[bEndpoint])) {
   1057          #endif
   1058                  // Enable endpoint IT
   1059                  AT91C_BASE_OTGHS->OTGHS_DEVIER = (1<<SHIFT_INTERUPT<<bEndpoint);
   1060                  AT91C_BASE_OTGHS->OTGHS_DEVEPTIER[bEndpoint] = AT91C_OTGHS_TXINI;
   1061          
   1062          #ifdef DMA
   1063              }
   1064              else {
   1065                  if( pTransfer->remaining == 0 ) {
   1066          
   1067                      // DMA not handle ZLP
   1068                      AT91C_BASE_OTGHS->OTGHS_DEVEPTICR[bEndpoint] = AT91C_OTGHS_TXINI;
   1069                      // For a non-control endpoint, the FIFOCON bit must be cleared
   1070                      // to start the transfer
   1071                      if ((AT91C_OTGHS_EPT_TYPE & AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[bEndpoint])
   1072                          != AT91C_OTGHS_EPT_TYPE_CTL_EPT) {
   1073          
   1074                          AT91C_BASE_OTGHS->OTGHS_DEVEPTIDR[bEndpoint] = AT91C_OTGHS_FIFOCON;
   1075                      }            
   1076                      AT91C_BASE_OTGHS->OTGHS_DEVEPTIDR[bEndpoint] = AT91C_OTGHS_TXINI;
   1077          
   1078                      // Enable endpoint IT
   1079                      AT91C_BASE_OTGHS->OTGHS_DEVIER = (1<<SHIFT_INTERUPT<<bEndpoint);
   1080                  }
   1081                  else {
   1082                      // Others endpoints (not control)
   1083                      if( pTransfer->remaining > DMA_MAX_FIFO_SIZE ) {
   1084          
   1085                          // Transfer the max
   1086                          pTransfer->buffered = DMA_MAX_FIFO_SIZE;    
   1087                      }
   1088                      else {
   1089                          // Transfer the good size
   1090                          pTransfer->buffered = pTransfer->remaining;
   1091                      }
   1092          
   1093                      TRACE_DEBUG_WP("\n\r_WR:%d ", pTransfer->remaining );
   1094                      TRACE_DEBUG_WP("B:%d ", pTransfer->buffered );
   1095                      TRACE_DEBUG_WP("T:%d ", pTransfer->transferred );
   1096          
   1097                      AT91C_BASE_OTGHS->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMAADDRESS = (unsigned int)(pTransfer->pData);
   1098          
   1099                      // Clear unwanted interrupts
   1100                      AT91C_BASE_OTGHS->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMASTATUS;
   1101          
   1102                      // Enable DMA endpoint interrupt
   1103                      AT91C_BASE_OTGHS->OTGHS_DEVIER = (1<<SHIFT_DMA<<bEndpoint);
   1104                      // DMA config
   1105                      AT91C_BASE_OTGHS->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMACONTROL = 0; // raz
   1106                      AT91C_BASE_OTGHS->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMACONTROL = 
   1107                           (((pTransfer->buffered<<16)&AT91C_OTGHS_BUFF_LENGTH)
   1108                             | AT91C_OTGHS_END_B_EN
   1109                             | AT91C_OTGHS_END_BUFFIT
   1110                             | AT91C_OTGHS_CHANN_ENB);
   1111                  }
   1112              }
   1113          #endif
   1114          
   1115              return USBD_STATUS_SUCCESS;
   1116          }
   1117          
   1118          //------------------------------------------------------------------------------
   1119          /// Reads incoming data on an USB endpoint (OUT)
   1120          /// \param bEndpoint Index of endpoint
   1121          /// \param *pData  Data to be readen
   1122          /// \param dLength Data length to be receive
   1123          /// \param fCallback  Callback to be call after the success command
   1124          /// \param *pArgument Callback argument
   1125          /// \return USBD_STATUS_LOCKED or USBD_STATUS_SUCCESS
   1126          //------------------------------------------------------------------------------
   1127          char USBD_Read( unsigned char    bEndpoint,
   1128                          void             *pData,
   1129                          unsigned int     dLength,
   1130                          TransferCallback fCallback,
   1131                          void             *pArgument )
   1132          {
   1133              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   1134              Transfer *pTransfer = &(pEndpoint->transfer);
   1135            
   1136              // Return if the endpoint is not in IDLE state
   1137              if (pEndpoint->state != UDP_ENDPOINT_IDLE) {
   1138          
   1139                  return USBD_STATUS_LOCKED;
   1140              }
   1141          
   1142              TRACE_DEBUG_WP("Read%d(%d) ", bEndpoint, dLength);
   1143              //TRACE_ERROR_WP("Read%d(%d) ", bEndpoint, dLength);
   1144          
   1145              // Endpoint enters Receiving state
   1146              pEndpoint->state = UDP_ENDPOINT_RECEIVING;
   1147          
   1148              // Set the transfer descriptor
   1149              pTransfer->pData = pData;
   1150              pTransfer->remaining = dLength;
   1151              pTransfer->buffered = 0;
   1152              pTransfer->transferred = 0;
   1153              pTransfer->fCallback = fCallback;
   1154              pTransfer->pArgument = pArgument;
   1155          
   1156          #ifdef DMA
   1157              // Test if endpoint type control
   1158              if (AT91C_OTGHS_EPT_TYPE_CTL_EPT == (AT91C_OTGHS_EPT_TYPE & AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[bEndpoint])) {
   1159          #endif
   1160                  // Control endpoint
   1161                  // Enable endpoint IT
   1162                  AT91C_BASE_OTGHS->OTGHS_DEVIER = (1<<SHIFT_INTERUPT<<bEndpoint);
   1163                  AT91C_BASE_OTGHS->OTGHS_DEVEPTIER[bEndpoint] = AT91C_OTGHS_RXOUT;
   1164          #ifdef DMA
   1165              }
   1166              else {
   1167          
   1168                  TRACE_DEBUG_WP("Read%d(%d) ", bEndpoint, dLength);
   1169          
   1170                  // Others endpoints (not control)
   1171                  if( pTransfer->remaining > DMA_MAX_FIFO_SIZE ) {
   1172          
   1173                      // Transfer the max
   1174                      pTransfer->buffered = DMA_MAX_FIFO_SIZE;    
   1175                  }
   1176                  else {
   1177                      // Transfer the good size
   1178                      pTransfer->buffered = pTransfer->remaining;
   1179                  }
   1180          
   1181                  AT91C_BASE_OTGHS->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMAADDRESS = (unsigned int)(pTransfer->pData);
   1182          
   1183                  // Clear unwanted interrupts
   1184                  AT91C_BASE_OTGHS->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMASTATUS;
   1185          
   1186                  // Enable DMA endpoint interrupt
   1187                  AT91C_BASE_OTGHS->OTGHS_DEVIER = (1<<SHIFT_DMA<<bEndpoint);
   1188          
   1189                  TRACE_DEBUG_WP("\n\r_RR:%d ", pTransfer->remaining );
   1190                  TRACE_DEBUG_WP("B:%d ", pTransfer->buffered );
   1191                  TRACE_DEBUG_WP("T:%d ", pTransfer->transferred );
   1192          
   1193                  // DMA config
   1194                  AT91C_BASE_OTGHS->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMACONTROL = 0; // raz
   1195                  AT91C_BASE_OTGHS->OTGHS_DEVDMA[bEndpoint].OTGHS_DEVDMACONTROL =
   1196                                       (((pTransfer->buffered<<16)&AT91C_OTGHS_BUFF_LENGTH)
   1197                                         | AT91C_OTGHS_END_TR_EN
   1198                                         | AT91C_OTGHS_END_TR_IT
   1199                                         | AT91C_OTGHS_END_B_EN
   1200                                         | AT91C_OTGHS_END_BUFFIT
   1201                                         | AT91C_OTGHS_CHANN_ENB);
   1202              }
   1203          #endif
   1204          
   1205            return USBD_STATUS_SUCCESS;
   1206          }
   1207          
   1208          //------------------------------------------------------------------------------
   1209          /// Put endpoint into Halt state
   1210          /// \param bEndpoint Index of endpoint
   1211          //------------------------------------------------------------------------------
   1212          void USBD_Halt( unsigned char bEndpoint )
   1213          {
   1214              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   1215          
   1216              TRACE_INFO("usbd_Halt%d ", bEndpoint);
   1217              //TRACE_ERROR("usbd_Halt%d ", bEndpoint);
   1218          
   1219              // Check that endpoint is enabled and not already in Halt state
   1220              if( (pEndpoint->state != UDP_ENDPOINT_DISABLED)
   1221               && (pEndpoint->state != UDP_ENDPOINT_HALTED) ) {
   1222          
   1223                  TRACE_INFO("Halt%d ", bEndpoint);
   1224          
   1225                  // Abort the current transfer if necessary
   1226                  OTGHS_EndOfTransfer(bEndpoint, USBD_STATUS_ABORTED);
   1227          
   1228                  pEndpoint->state = UDP_ENDPOINT_HALTED;
   1229                  // Put endpoint into Halt state
   1230                  AT91C_BASE_OTGHS->OTGHS_DEVEPTIER[bEndpoint] = AT91C_OTGHS_STALLRQ;
   1231                  AT91C_BASE_OTGHS->OTGHS_DEVEPTIER[bEndpoint] = AT91C_OTGHS_STALL;
   1232             }
   1233          }
   1234          
   1235          //------------------------------------------------------------------------------
   1236          /// Clears the Halt feature on the given endpoint.
   1237          /// \param bEndpoint Index of endpoint
   1238          //------------------------------------------------------------------------------
   1239          void USBD_Unhalt( unsigned char bEndpoint )
   1240          {
   1241              unsigned int cfgSav;
   1242          
   1243              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   1244          
   1245              // Check if the endpoint is enabled
   1246              if (pEndpoint->state != UDP_ENDPOINT_DISABLED) {
   1247          
   1248                  TRACE_DEBUG_WP("Unhalt%d ", bEndpoint);
   1249                  //TRACE_ERROR("Unhalt%d ", bEndpoint);
   1250          
   1251                  // Return endpoint to Idle state
   1252                  pEndpoint->state = UDP_ENDPOINT_IDLE;
   1253          
   1254                  cfgSav = AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[bEndpoint];
   1255           
   1256                  // Reset Endpoint Fifos
   1257                  AT91C_BASE_OTGHS->OTGHS_DEVEPT |= (1<<bEndpoint<<16);
   1258                  AT91C_BASE_OTGHS->OTGHS_DEVEPT &= ~(1<<bEndpoint<<16);
   1259          
   1260                  AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[bEndpoint] = cfgSav;
   1261          
   1262                  if((AT91C_BASE_OTGHS->OTGHS_DEVEPTISR[bEndpoint]&AT91C_OTGHS_CFGOK)==0) {
   1263          
   1264                      TRACE_ERROR("PB bEndpoint: 0x%X\n\r", bEndpoint);
   1265                      for(;;);
   1266                  }
   1267          
   1268                  // Reset data-toggle
   1269                  AT91C_BASE_OTGHS->OTGHS_DEVEPTIER[bEndpoint] = AT91C_OTGHS_RSTDT;
   1270          
   1271                  // Clear FORCESTALL flag
   1272                  // Disable stall on endpoint
   1273                  AT91C_BASE_OTGHS->OTGHS_DEVEPTIDR[bEndpoint] = AT91C_OTGHS_STALLRQ;
   1274                  AT91C_BASE_OTGHS->OTGHS_DEVEPTICR[bEndpoint] = AT91C_OTGHS_STALL;
   1275              }
   1276          }
   1277          
   1278          //------------------------------------------------------------------------------
   1279          /// Returns the current Halt status of an endpoint.
   1280          /// \param bEndpoint Index of endpoint
   1281          /// \return 1 if the endpoint is currently halted; otherwise 0
   1282          //------------------------------------------------------------------------------
   1283          unsigned char USBD_IsHalted( unsigned char bEndpoint )
   1284          {
   1285              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   1286              unsigned char status = 0;
   1287          
   1288              if (pEndpoint->state == UDP_ENDPOINT_HALTED) {
   1289                  status = 1;
   1290              }
   1291              return( status );
   1292          }
   1293          
   1294          //------------------------------------------------------------------------------
   1295          /// IS High Speed device working in High Speed ?
   1296          /// \return 1 if the device is in High Speed; otherwise 0 (Full Speed)
   1297          //------------------------------------------------------------------------------
   1298          unsigned char USBD_IsHighSpeed( void )
   1299          {
   1300              unsigned char status = 0;
   1301          
   1302              if(AT91C_OTGHS_SPEED_SR_HS == (AT91C_BASE_OTGHS->OTGHS_SR & (0x03<<12))) {
   1303                  // High Speed
   1304                  TRACE_DEBUG_WP("High Speed\n\r");
   1305                  status = 1;
   1306              }
   1307              else {
   1308                  TRACE_DEBUG_WP("Full Speed\n\r");
   1309              }
   1310              return( status );
   1311          }
   1312          
   1313          //------------------------------------------------------------------------------
   1314          /// Causes the endpoint to acknowledge the next received packet with a STALL
   1315          /// handshake.
   1316          /// Further packets are then handled normally.
   1317          /// \param bEndpoint Index of endpoint
   1318          /// \return Operation result code: USBD_STATUS_LOCKED or USBD_STATUS_SUCCESS
   1319          //------------------------------------------------------------------------------
   1320          unsigned char USBD_Stall( unsigned char bEndpoint )
   1321          {
   1322              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   1323          
   1324              // Check that endpoint is in Idle state
   1325              if (pEndpoint->state != UDP_ENDPOINT_IDLE) {
   1326          
   1327                  TRACE_WARNING("UDP_Stall: Endpoint%d locked\n\r", bEndpoint);
   1328                  return USBD_STATUS_LOCKED;
   1329              }
   1330          
   1331              TRACE_DEBUG_WP("Stall%d ", bEndpoint);
   1332          
   1333              AT91C_BASE_OTGHS->OTGHS_DEVEPTIER[bEndpoint] = AT91C_OTGHS_STALLRQ;
   1334          
   1335              return USBD_STATUS_SUCCESS;
   1336          }
   1337          
   1338          //------------------------------------------------------------------------------
   1339          /// Activates a remote wakeup procedure
   1340          //------------------------------------------------------------------------------
   1341          void USBD_RemoteWakeUp(void)
   1342          {
   1343              TRACE_DEBUG_WP("Remote WakeUp\n\r");
   1344          
   1345              // Device is currently suspended
   1346              if (deviceState == USBD_STATE_SUSPENDED) {
   1347          
   1348                  TRACE_DEBUG_WP("RW\n\r");
   1349                  OTGHS_EnableUsbClock();
   1350                  OTGHS_EnableTransceiver();
   1351          
   1352                  // Activates a remote wakeup
   1353                  AT91C_BASE_OTGHS->OTGHS_DEVCTRL |= AT91C_OTGHS_RMWKUP;
   1354              }
   1355              // Device is NOT suspended
   1356              else {
   1357          
   1358                  TRACE_WARNING("USBD_RemoteWakeUp: Device is not suspended\n\r");
   1359              }
   1360          }
   1361          
   1362          //------------------------------------------------------------------------------
   1363          /// Sets the device address
   1364          /// \param address Adress to be set
   1365          //------------------------------------------------------------------------------
   1366          void USBD_SetAddress( unsigned char address )
   1367          {
   1368              TRACE_DEBUG_WP("SetAddr(%d) ", address);
   1369          
   1370              // Set address
   1371              AT91C_BASE_OTGHS->OTGHS_DEVCTRL &= ~(AT91C_OTGHS_UADD);
   1372              AT91C_BASE_OTGHS->OTGHS_DEVCTRL |= address & AT91C_OTGHS_UADD;
   1373              AT91C_BASE_OTGHS->OTGHS_DEVCTRL |= AT91C_OTGHS_ADDEN;
   1374          
   1375              // If the address is 0, the device returns to the Default state
   1376              if (address == 0) {
   1377                  deviceState = USBD_STATE_DEFAULT;
   1378              }
   1379              // If the address is non-zero, the device enters the Address state
   1380              else {
   1381                  deviceState = USBD_STATE_ADDRESS;
   1382              }
   1383          }
   1384          
   1385          //------------------------------------------------------------------------------
   1386          /// Changes the device state from Address to Configured, or from Configured 
   1387          /// to Address.
   1388          /// This method directly access the last received SETUP packet to decide on 
   1389          /// what to do.
   1390          /// \param cfgnum configuration number
   1391          //------------------------------------------------------------------------------
   1392          void USBD_SetConfiguration( unsigned char cfgnum )
   1393          {
   1394              TRACE_DEBUG_WP("SetCfg(%d) ", cfgnum);
   1395          
   1396              // Check the request
   1397              if( cfgnum != 0 ) {
   1398          
   1399                  // Enter Configured state
   1400                  deviceState = USBD_STATE_CONFIGURED;
   1401              }
   1402              // If the configuration number is zero, the device goes back to the Address
   1403              // state
   1404              else  {
   1405          
   1406                  // Go back to Address state
   1407                  deviceState = USBD_STATE_ADDRESS;
   1408          
   1409                  // Abort all transfers
   1410                  OTGHS_DisableEndpoints();
   1411              }
   1412          }
   1413          
   1414          
   1415          //------------------------------------------------------------------------------
   1416          /// Enables the pull-up on the D+ line to connect the device to the USB.
   1417          //------------------------------------------------------------------------------
   1418          void USBD_Connect( void )
   1419          {
   1420              TRACE_DEBUG_WP("Conn ");
   1421          #if defined(BOARD_USB_PULLUP_INTERNAL)
   1422              AT91C_BASE_OTGHS->OTGHS_DEVCTRL &= ~AT91C_OTGHS_DETACH;
   1423          #else
   1424              #error "not defined"
   1425          #endif
   1426          }
   1427          
   1428          //------------------------------------------------------------------------------
   1429          /// Disables the pull-up on the D+ line to disconnect the device from the bus.
   1430          //------------------------------------------------------------------------------
   1431          void USBD_Disconnect( void )
   1432          {
   1433              TRACE_DEBUG_WP("Disc ");
   1434          #if defined(BOARD_USB_PULLUP_INTERNAL)
   1435              AT91C_BASE_OTGHS->OTGHS_DEVCTRL |= AT91C_OTGHS_DETACH;
   1436          
   1437          #else
   1438              #error "not defined"
   1439          #endif
   1440              // Device returns to the Powered state
   1441              if (deviceState > USBD_STATE_POWERED) {    
   1442          
   1443                  deviceState = USBD_STATE_POWERED;
   1444              }
   1445          }
   1446          
   1447          //------------------------------------------------------------------------------
   1448          /// Certification test for High Speed device.
   1449          /// \param bIndex Test to be done
   1450          //------------------------------------------------------------------------------
   1451          void USBD_Test( unsigned char bIndex )
   1452          {
   1453              char          *pFifo;
   1454              unsigned char i;
   1455          
   1456              AT91C_BASE_OTGHS->OTGHS_DEVIDR &= ~AT91C_OTGHS_SUSP;
   1457              AT91C_BASE_OTGHS->OTGHS_DEVCTRL |= AT91C_OTGHS_SPDCONF_HS; // remove suspend ?
   1458          
   1459              switch( bIndex ) {
   1460                  case USBFeatureRequest_TESTPACKET:
   1461                      TRACE_DEBUG_WP("TEST_PACKET ");
   1462          
   1463                      AT91C_BASE_OTGHS->OTGHS_DEVDMA[1].OTGHS_DEVDMACONTROL = 0; // raz
   1464                      AT91C_BASE_OTGHS->OTGHS_DEVDMA[2].OTGHS_DEVDMACONTROL = 0; // raz
   1465          
   1466                      // Configure endpoint 2, 64 bytes, direction IN, type BULK, 1 bank
   1467                      AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[2] = AT91C_OTGHS_EPT_SIZE_64
   1468                                                                   | AT91C_OTGHS_EPT_DIR_IN  
   1469                                                                   | AT91C_OTGHS_EPT_TYPE_BUL_EPT 
   1470                                                                   | AT91C_OTGHS_BK_NUMBER_1;
   1471                      // Check if the configuration is ok
   1472                      AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[2] |= AT91C_OTGHS_ALLOC;
   1473                      while((AT91C_BASE_OTGHS->OTGHS_DEVEPTISR[2]&AT91C_OTGHS_CFGOK)==0) {
   1474                      }
   1475          
   1476                      AT91C_BASE_OTGHS->OTGHS_DEVEPT |= AT91C_OTGHS_EPEN2;
   1477          
   1478                      // Write FIFO
   1479                      pFifo = (char*)((unsigned int *)AT91C_BASE_OTGHS_EPTFIFO + (EPT_VIRTUAL_SIZE * 2));
   1480                      for( i=0; i<sizeof(test_packet_buffer); i++) {
   1481                          pFifo[i] = test_packet_buffer[i];
   1482                      }
   1483                      // Tst PACKET
   1484                      AT91C_BASE_OTGHS->OTGHS_DEVCTRL |= AT91C_OTGHS_TSTPCKT;
   1485                      // Send packet
   1486                      AT91C_BASE_OTGHS->OTGHS_DEVEPTICR[2] = AT91C_OTGHS_TXINI;
   1487                      break;
   1488          
   1489                  case USBFeatureRequest_TESTJ:
   1490                      TRACE_DEBUG_WP("TEST_J ");
   1491                      AT91C_BASE_OTGHS->OTGHS_DEVCTRL |= AT91C_OTGHS_TSTJ;
   1492                      break;
   1493          
   1494                  case USBFeatureRequest_TESTK:
   1495                      TRACE_DEBUG_WP("TEST_K ");
   1496                      AT91C_BASE_OTGHS->OTGHS_DEVCTRL |= AT91C_OTGHS_TSTK;
   1497                      break;
   1498          
   1499                  case USBFeatureRequest_TESTSE0NAK:
   1500                      TRACE_DEBUG_WP("TEST_SEO_NAK ");
   1501                      AT91C_BASE_OTGHS->OTGHS_DEVIDR = 0xFFFFFFFF;
   1502                      break;
   1503          
   1504                  case USBFeatureRequest_TESTSENDZLP:
   1505                      //while( 0 != (AT91C_BASE_UDPHS->UDPHS_EPT[0].UDPHS_EPTSTA & AT91C_UDPHS_TX_PK_RDY ) ) {}
   1506                      AT91C_BASE_OTGHS->OTGHS_DEVEPTICR[0] = AT91C_OTGHS_TXINI;
   1507                      //while( 0 != (AT91C_BASE_UDPHS->UDPHS_EPT[0].UDPHS_EPTSTA & AT91C_UDPHS_TX_PK_RDY ) ) {}
   1508                      TRACE_DEBUG_WP("SEND_ZLP ");
   1509                      break;
   1510              }
   1511              TRACE_DEBUG_WP("\n\r");
   1512          }
   1513          
   1514          //------------------------------------------------------------------------------
   1515          /// Initializes the specified USB driver
   1516          /// This function initializes the current FIFO bank of endpoints,
   1517          /// configures the pull-up and VBus lines, disconnects the pull-up and
   1518          /// then trigger the Init callback.
   1519          //------------------------------------------------------------------------------
   1520          void USBD_Init(void)
   1521          {
   1522              // forceFS must not be used !
   1523              int i;
   1524          
   1525              TRACE_DEBUG_WP("USBD Init()\n\r");
   1526          
   1527              // disable Watchdog
   1528              AT91C_BASE_WDTC->WDTC_WDMR = AT91C_WDTC_WDDIS;
   1529          
   1530                  // Enable USB macro
   1531              *AT91C_OTGHS_CTRL |= AT91C_OTGHS_USBECTRL;
   1532          
   1533              // Automatic mode speed for device
   1534              *AT91C_OTGHS_DEVCTRL &= ~AT91C_OTGHS_SPDCONF_FS;  // Normal mode
   1535          
   1536              *AT91C_OTGHS_DEVCTRL &= ~(  AT91C_OTGHS_LS   | AT91C_OTGHS_TSTJ
   1537                                        | AT91C_OTGHS_TSTK | AT91C_OTGHS_TSTPCKT
   1538                                        | AT91C_OTGHS_OPMODE2 ); // Normal mode
   1539          
   1540              AT91C_BASE_OTGHS->OTGHS_DEVCTRL = 0;
   1541              AT91C_BASE_OTGHS->OTGHS_HSTCTRL = 0;
   1542          
   1543              // Enable OTG pad
   1544              *AT91C_OTGHS_CTRL |= AT91C_OTGHS_OTGPADE;
   1545          
   1546              // Enable clock OTG pad
   1547              *AT91C_OTGHS_CTRL &= ~AT91C_OTGHS_FRZCLKCTRL;
   1548          
   1549              //Usb_disable();
   1550              AT91C_BASE_OTGHS->OTGHS_CTRL &= ~AT91C_OTGHS_USBECTRL;
   1551              AT91C_BASE_OTGHS->OTGHS_CTRL &= ~AT91C_OTGHS_OTGPADE;
   1552              AT91C_BASE_OTGHS->OTGHS_CTRL |= AT91C_OTGHS_FRZCLKCTRL;
   1553              //Usb_enable();
   1554              AT91C_BASE_OTGHS->OTGHS_CTRL |= AT91C_OTGHS_USBECTRL;
   1555              AT91C_BASE_OTGHS->OTGHS_CTRL |= AT91C_OTGHS_OTGPADE;
   1556              AT91C_BASE_OTGHS->OTGHS_CTRL &= ~AT91C_OTGHS_FRZCLKCTRL;
   1557              //Usb_select_device();
   1558              AT91C_BASE_OTGHS->OTGHS_CTRL &= ~AT91C_OTGHS_UIDE;
   1559              AT91C_BASE_OTGHS->OTGHS_CTRL |= AT91C_OTGHS_UIMOD;
   1560          
   1561              // Device is in the Attached state
   1562              deviceState = USBD_STATE_SUSPENDED;
   1563              previousDeviceState = USBD_STATE_POWERED;
   1564          
   1565              
   1566              PMC_EnablePeripheral(AT91C_ID_OTGHS);
   1567               
   1568              // Reset endpoint structures
   1569              OTGHS_ResetEndpoints();
   1570          
   1571              // Enables the USB Clock
   1572              OTGHS_EnableUsbClock();
   1573          
   1574              //926C
   1575              // Enable USB macro and clear all other bit
   1576              AT91C_BASE_OTGHS->OTGHS_CTRL |= AT91C_OTGHS_USBECTRL;
   1577              AT91C_BASE_OTGHS->OTGHS_CTRL = AT91C_OTGHS_USBECTRL;
   1578           
   1579              // Configure the pull-up on D+ and disconnect it
   1580              USBD_Disconnect();
   1581          
   1582              // Enable clock OTG pad
   1583              AT91C_BASE_OTGHS->OTGHS_CTRL &= ~AT91C_OTGHS_FRZCLKCTRL;
   1584             TRACE_DEBUG("AT91C_OTGHS_CTRL: 0x%X\n\r", AT91C_BASE_OTGHS->OTGHS_CTRL );
   1585          
   1586              // Clear General IT
   1587              AT91C_BASE_OTGHS->OTGHS_SCR = 0x01FF;
   1588          
   1589              // Clear OTG Device IT
   1590              AT91C_BASE_OTGHS->OTGHS_DEVICR = 0xFF;
   1591          
   1592              // Clear OTG Host IT
   1593              AT91C_BASE_OTGHS->OTGHS_HSTICR = 0x7F;
   1594          
   1595              // Reset all Endpoints Fifos
   1596              AT91C_BASE_OTGHS->OTGHS_DEVEPT |= (0x7F<<16);
   1597              AT91C_BASE_OTGHS->OTGHS_DEVEPT &= ~(0x7F<<16);
   1598          
   1599              // Disable all endpoints
   1600              AT91C_BASE_OTGHS->OTGHS_DEVEPT &= ~0x7F;
   1601          
   1602              AT91C_BASE_OTGHS->OTGHS_TSTA2 = 0;
   1603          
   1604              // Device is in the Attached state
   1605              deviceState = USBD_STATE_SUSPENDED;
   1606              previousDeviceState = USBD_STATE_POWERED;
   1607          
   1608              // Automatic mode speed for device
   1609              AT91C_BASE_OTGHS->OTGHS_DEVCTRL &= ~AT91C_OTGHS_SPDCONF_FS;
   1610              // Force Full Speed mode for device
   1611              //*AT91C_OTGHS_DEVCTRL = AT91C_OTGHS_SPDCONF_FS;
   1612              // Force High Speed mode for device
   1613              //*AT91C_OTGHS_DEVCTRL = AT91C_OTGHS_SPDCONF_HS;
   1614          
   1615              AT91C_BASE_OTGHS->OTGHS_DEVCTRL &= ~(  AT91C_OTGHS_LS 
   1616                                                   | AT91C_OTGHS_TSTJ
   1617                                                   | AT91C_OTGHS_TSTK
   1618                                                   | AT91C_OTGHS_TSTPCKT
   1619                                                   | AT91C_OTGHS_OPMODE2 );
   1620          
   1621          
   1622              // Automatic mode speed for host
   1623              AT91C_BASE_OTGHS->OTGHS_HSTCTRL &= ~AT91C_OTGHS_SPDCONF_HST_FS;
   1624              // Force Full Speed mode for host
   1625              //AT91C_BASE_OTGHS->OTGHS_HSTCTRL = AT91C_OTGHS_SPDCONF_HST_FS;
   1626              // Force High Speed mode for host
   1627              //*AT91C_BASE_OTGHS->OTGHS_HSTCTRL = AT91C_OTGHS_SPDCONF_HST_HS;
   1628          
   1629              // Enable the UID pin select
   1630              AT91C_BASE_OTGHS->OTGHS_CTRL |= AT91C_OTGHS_UIDE;
   1631           
   1632              // Enable USB macro
   1633              AT91C_BASE_OTGHS->OTGHS_CTRL |= AT91C_OTGHS_USBECTRL;
   1634          
   1635              // Enable OTG pad
   1636              AT91C_BASE_OTGHS->OTGHS_CTRL |= AT91C_OTGHS_OTGPADE;
   1637          
   1638              // Enable clock OTG pad
   1639              AT91C_BASE_OTGHS->OTGHS_CTRL &= ~AT91C_OTGHS_FRZCLKCTRL;
   1640          
   1641          
   1642              // With OR without DMA !!!
   1643              // Initialization of DMA
   1644              for( i=1; i<=((AT91C_BASE_OTGHS->OTGHS_IPFEATURES & AT91C_OTGHS_DMA_CHANNEL_NBR)>>4); i++ ) {
   1645          
   1646                  // RESET endpoint canal DMA:
   1647                  // DMA stop channel command
   1648                  AT91C_BASE_OTGHS->OTGHS_DEVDMA[i].OTGHS_DEVDMACONTROL = 0;  // STOP command
   1649          
   1650                  // Disable endpoint
   1651                  AT91C_BASE_OTGHS->OTGHS_DEVEPTIDR[i] = 0XFFFFFFFF;
   1652          
   1653                  // Reset endpoint config
   1654                  AT91C_BASE_OTGHS->OTGHS_DEVEPTCFG[i] = 0;
   1655          
   1656                  // Reset DMA channel (Buff count and Control field)
   1657                  AT91C_BASE_OTGHS->OTGHS_DEVDMA[i].OTGHS_DEVDMACONTROL = 0x02;  // NON STOP command
   1658          
   1659                  // Reset DMA channel 0 (STOP)
   1660                  AT91C_BASE_OTGHS->OTGHS_DEVDMA[i].OTGHS_DEVDMACONTROL = 0;  // STOP command
   1661          
   1662                  // Clear DMA channel status (read the register for clear it)
   1663                  AT91C_BASE_OTGHS->OTGHS_DEVDMA[i].OTGHS_DEVDMASTATUS = AT91C_BASE_OTGHS->OTGHS_DEVDMA[i].OTGHS_DEVDMASTATUS;
   1664          
   1665              }
   1666          
   1667              
   1668              // Configure interrupts
   1669              USBDCallbacks_Initialized();
   1670          
   1671              AT91C_BASE_OTGHS->OTGHS_CTRL |= AT91C_OTGHS_VBUSTI;
   1672          
   1673             TRACE_DEBUG("AT91C_OTGHS_CTRL: 0x%X\n\r", AT91C_BASE_OTGHS->OTGHS_CTRL );
   1674             TRACE_DEBUG("AT91C_OTGHS_SR: 0x%X\n\r", AT91C_BASE_OTGHS->OTGHS_SR );
   1675            
   1676              AT91C_BASE_OTGHS->OTGHS_DEVIER = AT91C_OTGHS_WAKEUP;
   1677              
   1678             TRACE_DEBUG("NUM_IT_MAX_DMA: 0x%X\n\r", NUM_IT_MAX_DMA );
   1679             TRACE_DEBUG("NUM_IT_MAX: 0x%X\n\r", NUM_IT_MAX );
   1680          
   1681          }
   1682          
   1683          
   1684          //------------------------------------------------------------------------------
   1685          /// Returns the current state of the USB device.
   1686          /// \return Device current state.
   1687          //------------------------------------------------------------------------------
   1688          unsigned char USBD_GetState( void )
   1689          {
   1690              return deviceState;
   1691          }
   1692          
   1693          #endif // BOARD_USB_OTGHS


 
 
 0 bytes of memory

Errors: none
Warnings: none
