###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.50.0.51878/W32 for ARM     14/Mar/2021  19:14:52 #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\Projects\in-18-nixie-clock\at91lib\usb\device\core\US #
#                    BD_UDP.c                                                 #
#    Command line =  C:\Projects\in-18-nixie-clock\at91lib\usb\device\core\US #
#                    BD_UDP.c -D at91sam7s128 -D flash -D TRACE_LEVEL=3 -lC   #
#                    C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\at91sam7s128_flash\List\ --remarks  #
#                    --diag_suppress Pe826,Pe1375 -o                          #
#                    C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\at91sam7s128_flash\Obj\ --debug     #
#                    --endian=little --cpu=ARM7TDMI -e --fpu=None             #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Full. #
#                    h" -I C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-dev #
#                    ice-cdc-serial-project\ewp\..\..\..\at91lib/peripherals\ #
#                     -I C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-devic #
#                    e-cdc-serial-project\ewp\..\..\..\at91lib/components\    #
#                    -I C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device #
#                    -cdc-serial-project\ewp\..\..\..\at91lib/usb/device\ -I  #
#                    C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\..\..\..\at91lib\ -I                #
#                    C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\..\..\..\external_libs\ -I          #
#                    C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\..\..\..\at91lib/boards/at91sam7s-e #
#                    k\ -I "C:\Program Files (x86)\IAR Systems\Embedded       #
#                    Workbench 5.4\arm\INC\" --interwork --cpu_mode arm -Ohz  #
#    List file    =  C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\at91sam7s128_flash\List\USBD_UDP.ls #
#                    t                                                        #
#    Object file  =  C:\Projects\in-18-nixie-clock\at91sam7s-ek\usb-device-cd #
#                    c-serial-project\ewp\at91sam7s128_flash\Obj\USBD_UDP.o   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Projects\in-18-nixie-clock\at91lib\usb\device\core\USBD_UDP.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** 
     31           \unit
     32          
     33           !!!Purpose
     34          
     35              Implementation of USB device functions on a UDP controller.
     36          
     37              See "USBD API Methods".
     38          */
     39          
     40          //------------------------------------------------------------------------------
     41          //      Headers
     42          //------------------------------------------------------------------------------
     43          
     44          #include "USBD.h"
     45          #include "USBDCallbacks.h"
     46          #include <board.h>
     47          #include <pio/pio.h>
     48          #include <utility/trace.h>
     49          #include <utility/led.h>
     50          #include <usb/common/core/USBEndpointDescriptor.h>
     51          #include <usb/common/core/USBGenericRequest.h>
     52          
     53          #if defined(BOARD_USB_UDP)
     54          
     55          //------------------------------------------------------------------------------
     56          //         Definitions
     57          //------------------------------------------------------------------------------
     58          
     59          //------------------------------------------------------------------------------
     60          /// \page "UDP register field values"
     61          ///
     62          /// This page lists the initialize values of UDP registers.
     63          ///
     64          /// !Values
     65          /// - UDP_RXDATA
     66          
     67          /// Bit mask for both banks of the UDP_CSR register.
     68          #define UDP_RXDATA              (AT91C_UDP_RX_DATA_BK0 | AT91C_UDP_RX_DATA_BK1)
     69          //------------------------------------------------------------------------------
     70          
     71          //------------------------------------------------------------------------------
     72          /// \page "Endpoint states"
     73          ///
     74          /// This page lists the endpoint states.
     75          ///
     76          /// !States
     77          //  - UDP_ENDPOINT_DISABLED
     78          //  - UDP_ENDPOINT_HALTED
     79          //  - UDP_ENDPOINT_IDLE
     80          //  - UDP_ENDPOINT_SENDING
     81          //  - UDP_ENDPOINT_RECEIVING
     82          
     83          /// Endpoint states: Endpoint is disabled
     84          #define UDP_ENDPOINT_DISABLED       0
     85          /// Endpoint states: Endpoint is halted (i.e. STALLs every request)
     86          #define UDP_ENDPOINT_HALTED         1
     87          /// Endpoint states: Endpoint is idle (i.e. ready for transmission)
     88          #define UDP_ENDPOINT_IDLE           2
     89          /// Endpoint states: Endpoint is sending data
     90          #define UDP_ENDPOINT_SENDING        3
     91          /// Endpoint states: Endpoint is receiving data
     92          #define UDP_ENDPOINT_RECEIVING      4
     93          //------------------------------------------------------------------------------
     94          
     95          //------------------------------------------------------------------------------
     96          /// \page "UDP_CSR register access"
     97          ///
     98          /// This page lists the macroes to access UDP CSR register.
     99          ///
    100          /// !Macros
    101          /// - CLEAR_CSR
    102          /// - SET_CSR
    103          
    104          /// Bitmap for all status bits in CSR.
    105          #define REG_NO_EFFECT_1_ALL      AT91C_UDP_RX_DATA_BK0 | AT91C_UDP_RX_DATA_BK1 \
    106                                          |AT91C_UDP_STALLSENT   | AT91C_UDP_RXSETUP \
    107                                          |AT91C_UDP_TXCOMP
    108          
    109          /// Clears the specified bit(s) in the UDP_CSR register.
    110          /// \param endpoint The endpoint number of the CSR to process.
    111          /// \param flags The bitmap to set to 1.
    112          #define SET_CSR(endpoint, flags) \
    113              { \
    114                  volatile unsigned int reg; \
    115                  reg = AT91C_BASE_UDP->UDP_CSR[endpoint] ; \
    116                  reg |= REG_NO_EFFECT_1_ALL; \
    117                  reg |= (flags); \
    118                  AT91C_BASE_UDP->UDP_CSR[endpoint] = reg; \
    119                  while ( (AT91C_BASE_UDP->UDP_CSR[endpoint] & (flags)) != (flags)); \
    120              }
    121          
    122          /// Sets the specified bit(s) in the UDP_CSR register.
    123          /// \param endpoint The endpoint number of the CSR to process.
    124          /// \param flags The bitmap to clear to 0.
    125          #define CLEAR_CSR(endpoint, flags) \
    126              { \
    127                  volatile unsigned int reg; \
    128                  reg = AT91C_BASE_UDP->UDP_CSR[endpoint]; \
    129                  reg |= REG_NO_EFFECT_1_ALL; \
    130                  reg &= ~(flags); \
    131                  AT91C_BASE_UDP->UDP_CSR[endpoint] = reg; \
    132                  while ( (AT91C_BASE_UDP->UDP_CSR[endpoint] & (flags)) == (flags)); \
    133              }
    134          //------------------------------------------------------------------------------
    135          
    136          //------------------------------------------------------------------------------
    137          //      Types
    138          //------------------------------------------------------------------------------
    139          
    140          /// Describes an ongoing transfer on a UDP endpoint.
    141          typedef struct {
    142          
    143              /// Pointer to a data buffer used for emission/reception.
    144              char             *pData;
    145              /// Number of bytes which have been written into the UDP internal FIFO
    146              /// buffers.
    147              volatile int     buffered;
    148              /// Number of bytes which have been sent/received.
    149              volatile int     transferred;
    150              /// Number of bytes which have not been buffered/transferred yet.
    151              volatile int     remaining;
    152              /// Optional callback to invoke when the transfer completes.
    153              volatile TransferCallback fCallback;
    154              /// Optional argument to the callback function.
    155              void             *pArgument;
    156          } Transfer;
    157          
    158          //------------------------------------------------------------------------------
    159          /// Describes the state of an endpoint of the UDP controller.
    160          //------------------------------------------------------------------------------
    161          typedef struct {
    162          
    163              /// Current endpoint state.
    164              volatile unsigned char  state;
    165              /// Current reception bank (0 or 1).
    166              volatile unsigned char  bank;
    167              /// Maximum packet size for the endpoint.
    168              volatile unsigned short size;
    169              /// Describes an ongoing transfer (if current state is either
    170              ///  <UDP_ENDPOINT_SENDING> or <UDP_ENDPOINT_RECEIVING>)
    171              Transfer       transfer;
    172          } Endpoint;
    173          
    174          //------------------------------------------------------------------------------
    175          //         Internal variables
    176          //------------------------------------------------------------------------------
    177          
    178          /// Holds the internal state for each endpoint of the UDP.

   \                                 In section .bss, align 4
    179          static Endpoint endpoints[BOARD_USB_NUMENDPOINTS];
   \                     endpoints:
   \   00000000                      DS8 112
    180          
    181          /// Device current state.

   \                                 In section .bss, align 1
    182          static unsigned char deviceState;
   \                     deviceState:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
    183          /// Indicates the previous device state
    184          static unsigned char previousDeviceState;
    185          
    186          //------------------------------------------------------------------------------
    187          //      Internal Functions
    188          //------------------------------------------------------------------------------
    189          
    190          //------------------------------------------------------------------------------
    191          /// Enables the clock of the UDP peripheral.
    192          //------------------------------------------------------------------------------
    193          static inline void UDP_EnablePeripheralClock(void)
    194          {
    195              AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_UDP;
    196          }
    197          
    198          //------------------------------------------------------------------------------
    199          /// Disables the UDP peripheral clock.
    200          //------------------------------------------------------------------------------
    201          static inline void UDP_DisablePeripheralClock(void)
    202          {
    203              AT91C_BASE_PMC->PMC_PCDR = 1 << AT91C_ID_UDP;
    204          }
    205          
    206          //------------------------------------------------------------------------------
    207          /// Enables the 48MHz USB clock.
    208          //------------------------------------------------------------------------------
    209          static inline void UDP_EnableUsbClock(void)
    210          {
    211              AT91C_BASE_PMC->PMC_SCER = AT91C_PMC_UDP;
    212          }
    213          
    214          //------------------------------------------------------------------------------
    215          ///  Disables the 48MHz USB clock.
    216          //------------------------------------------------------------------------------
    217          static inline void UDP_DisableUsbClock(void)
    218          {
    219              AT91C_BASE_PMC->PMC_SCDR = AT91C_PMC_UDP;
    220          }
    221          
    222          //------------------------------------------------------------------------------
    223          /// Enables the UDP transceiver.
    224          //------------------------------------------------------------------------------
    225          static inline void UDP_EnableTransceiver(void)
    226          {
    227              AT91C_BASE_UDP->UDP_TXVC &= ~AT91C_UDP_TXVDIS;
                                                 ^
Remark[Pe068]: integer conversion resulted in a change of sign
    228          }
    229          
    230          //------------------------------------------------------------------------------
    231          /// Disables the UDP transceiver.
    232          //------------------------------------------------------------------------------
    233          static inline void UDP_DisableTransceiver(void)
    234          {
    235              AT91C_BASE_UDP->UDP_TXVC |= AT91C_UDP_TXVDIS;
    236          }
    237          
    238          //------------------------------------------------------------------------------
    239          /// Handles a completed transfer on the given endpoint, invoking the
    240          /// configured callback if any.
    241          /// \param bEndpoint Number of the endpoint for which the transfer has completed.
    242          /// \param bStatus   Status code returned by the transfer operation
    243          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    244          static void UDP_EndOfTransfer(unsigned char bEndpoint, char bStatus)
    245          {
   \                     UDP_EndOfTransfer:
   \   00000000   00502DE9           PUSH     {R12,LR}
    246              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   \   00000004   1C20A0E3           MOV      R2,#+28
   \   00000008   ........           LDR      R3,??DataTable16
   \   0000000C   923020E0           MLA      R0,R2,R0,R3
    247              Transfer *pTransfer = &(pEndpoint->transfer);
   \   00000010   04C080E2           ADD      R12,R0,#+4
    248          
    249              // Check that endpoint was sending or receiving data
    250              if( (pEndpoint->state == UDP_ENDPOINT_RECEIVING)
    251                  || (pEndpoint->state == UDP_ENDPOINT_SENDING)) {
   \   00000014   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000018   040052E3           CMP      R2,#+4
   \   0000001C   0020D015           LDRBNE   R2,[R0, #+0]
   \   00000020   03005213           CMPNE    R2,#+3
   \   00000024   0C00001A           BNE      ??UDP_EndOfTransfer_0
    252          
    253                  TRACE_DEBUG_WP("EoT ");
    254          
    255                  // Endpoint returns in Idle state
    256                  pEndpoint->state = UDP_ENDPOINT_IDLE;
   \   00000028   0220A0E3           MOV      R2,#+2
   \   0000002C   0020C0E5           STRB     R2,[R0, #+0]
    257          
    258                  // Invoke callback is present
    259                  if (pTransfer->fCallback != 0) {
   \   00000030   10009CE5           LDR      R0,[R12, #+16]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0700000A           BEQ      ??UDP_EndOfTransfer_0
    260          
    261                      ((TransferCallback) pTransfer->fCallback)
    262                          (pTransfer->pArgument,
    263                           bStatus,
    264                           pTransfer->transferred,
    265                           pTransfer->remaining + pTransfer->buffered);
   \   0000003C   0C009CE5           LDR      R0,[R12, #+12]
   \   00000040   04209CE5           LDR      R2,[R12, #+4]
   \   00000044   003082E0           ADD      R3,R2,R0
   \   00000048   08209CE5           LDR      R2,[R12, #+8]
   \   0000004C   14009CE5           LDR      R0,[R12, #+20]
   \   00000050   10C09CE5           LDR      R12,[R12, #+16]
   \   00000054   0FE0A0E1           MOV      LR,PC
   \   00000058   1CFF2FE1           BX       R12
    266                  }
    267                  else {
    268                      TRACE_DEBUG_WP("NoCallBack ");
    269                  }
    270              }
    271          }
   \                     ??UDP_EndOfTransfer_0:
   \   0000005C   ........           B        ?Subroutine0

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0140BDE8           POP      {R0,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
    272          
    273          //------------------------------------------------------------------------------
    274          /// Clears the correct reception flag (bank 0 or bank 1) of an endpoint
    275          /// \param bEndpoint Index of endpoint
    276          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    277          static void UDP_ClearRxFlag(unsigned char bEndpoint)
    278          {
   \                     UDP_ClearRxFlag:
   \   00000000   04D04DE2           SUB      SP,SP,#+4
    279              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   \   00000004   0010A0E1           MOV      R1,R0
   \   00000008   1C30A0E3           MOV      R3,#+28
   \   0000000C   ........           LDR      R2,??DataTable16
   \   00000010   932122E0           MLA      R2,R3,R1,R2
    280          
    281              // Clear flag and change banks
    282              if (pEndpoint->bank == 0) {
   \   00000014   ........           LDR      R3,??DataTable16_1  ;; 0xfffb0030
   \   00000018   01C0D2E5           LDRB     R12,[R2, #+1]
   \   0000001C   00005CE3           CMP      R12,#+0
   \   00000020   1100001A           BNE      ??UDP_ClearRxFlag_0
    283          
    284                  CLEAR_CSR(bEndpoint, AT91C_UDP_RX_DATA_BK0);
                         ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   00000024   01C193E7           LDR      R12,[R3, +R1, LSL #+2]
   \   00000028   00C08DE5           STR      R12,[SP, #+0]
   \   0000002C   00C09DE5           LDR      R12,[SP, #+0]
   \   00000030   4FC08CE3           ORR      R12,R12,#0x4F
   \   00000034   00C08DE5           STR      R12,[SP, #+0]
   \   00000038   00C09DE5           LDR      R12,[SP, #+0]
   \   0000003C   02C0CCE3           BIC      R12,R12,#0x2
   \   00000040   00C08DE5           STR      R12,[SP, #+0]
   \   00000044   00C09DE5           LDR      R12,[SP, #+0]
   \   00000048   01C183E7           STR      R12,[R3, +R1, LSL #+2]
   \                     ??UDP_ClearRxFlag_1:
   \   0000004C   01C193E7           LDR      R12,[R3, +R1, LSL #+2]
   \   00000050   02001CE3           TST      R12,#0x2
   \   00000054   FCFFFF1A           BNE      ??UDP_ClearRxFlag_1
    285                  // Swap bank if in dual-fifo mode
    286                  if (BOARD_USB_ENDPOINTS_BANKS(bEndpoint) > 1) {
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   03005013           CMPNE    R0,#+3
   \   00000060   1000000A           BEQ      ??UDP_ClearRxFlag_2
    287          
    288                      pEndpoint->bank = 1;
   \   00000064   0100A0E3           MOV      R0,#+1
   \   00000068   0D0000EA           B        ??UDP_ClearRxFlag_3
    289                  }
    290              }
    291              else {
    292          
    293                  CLEAR_CSR(bEndpoint, AT91C_UDP_RX_DATA_BK1);
                         ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \                     ??UDP_ClearRxFlag_0:
   \   0000006C   010193E7           LDR      R0,[R3, +R1, LSL #+2]
   \   00000070   00008DE5           STR      R0,[SP, #+0]
   \   00000074   00009DE5           LDR      R0,[SP, #+0]
   \   00000078   4F0080E3           ORR      R0,R0,#0x4F
   \   0000007C   00008DE5           STR      R0,[SP, #+0]
   \   00000080   00009DE5           LDR      R0,[SP, #+0]
   \   00000084   4000C0E3           BIC      R0,R0,#0x40
   \   00000088   00008DE5           STR      R0,[SP, #+0]
   \   0000008C   00009DE5           LDR      R0,[SP, #+0]
   \   00000090   010183E7           STR      R0,[R3, +R1, LSL #+2]
   \                     ??UDP_ClearRxFlag_4:
   \   00000094   010193E7           LDR      R0,[R3, +R1, LSL #+2]
   \   00000098   400010E3           TST      R0,#0x40
   \   0000009C   FCFFFF1A           BNE      ??UDP_ClearRxFlag_4
    294                  pEndpoint->bank = 0;
   \   000000A0   0000A0E3           MOV      R0,#+0
   \                     ??UDP_ClearRxFlag_3:
   \   000000A4   0100C2E5           STRB     R0,[R2, #+1]
    295              }
    296          }
   \                     ??UDP_ClearRxFlag_2:
   \   000000A8   ........           B        ?Subroutine1

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine1:
   \   00000000   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000004   1EFF2FE1           BX       LR               ;; return
    297          
    298          //------------------------------------------------------------------------------
    299          /// Transfers a data payload from the current tranfer buffer to the endpoint
    300          /// FIFO
    301          /// \param bEndpoint Number of the endpoint which is sending data.
    302          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    303          static void UDP_WritePayload(unsigned char bEndpoint)
    304          {
   \                     UDP_WritePayload:
   \   00000000   00402DE9           PUSH     {LR}
    305              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   \   00000004   1C20A0E3           MOV      R2,#+28
   \   00000008   ........           LDR      R1,??DataTable16
   \   0000000C   921021E0           MLA      R1,R2,R0,R1
    306              Transfer *pTransfer = &(pEndpoint->transfer);
   \   00000010   042081E2           ADD      R2,R1,#+4
    307              signed int size;
    308          
    309              // Get the number of bytes to send
    310              size = pEndpoint->size;
   \   00000014   B210D1E1           LDRH     R1,[R1, #+2]
    311              if (size > pTransfer->remaining) {
   \   00000018   0C3092E5           LDR      R3,[R2, #+12]
   \   0000001C   010053E1           CMP      R3,R1
    312          
    313                  size = pTransfer->remaining;
   \   00000020   0C1092B5           LDRLT    R1,[R2, #+12]
    314              }
    315          
    316              // Update transfer descriptor information
    317              pTransfer->buffered += size;
   \   00000024   043092E5           LDR      R3,[R2, #+4]
   \   00000028   033081E0           ADD      R3,R1,R3
   \   0000002C   043082E5           STR      R3,[R2, #+4]
    318              pTransfer->remaining -= size;
   \   00000030   0C3092E5           LDR      R3,[R2, #+12]
   \   00000034   013043E0           SUB      R3,R3,R1
   \   00000038   0C3082E5           STR      R3,[R2, #+12]
   \   0000003C   ........           LDR      R12,??DataTable16_2  ;; 0xfffb0050
   \   00000040   040000EA           B        ??UDP_WritePayload_0
    319          
    320              // Write packet in the FIFO buffer
    321              while (size > 0) {
    322          
    323                  AT91C_BASE_UDP->UDP_FDR[bEndpoint] = *(pTransfer->pData);
   \                     ??UDP_WritePayload_1:
   \   00000044   003092E5           LDR      R3,[R2, #+0]
   \   00000048   01E0D3E4           LDRB     LR,[R3], #+1
   \   0000004C   00E18CE7           STR      LR,[R12, +R0, LSL #+2]
    324                  pTransfer->pData++;
   \   00000050   003082E5           STR      R3,[R2, #+0]
    325                  size--;
   \   00000054   011041E2           SUB      R1,R1,#+1
    326              }
   \                     ??UDP_WritePayload_0:
   \   00000058   010051E3           CMP      R1,#+1
   \   0000005C   F8FFFFAA           BGE      ??UDP_WritePayload_1
    327          }
   \   00000060   ........           B        ?Subroutine2

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0040BDE8           POP      {LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
    328          
    329          
    330          //------------------------------------------------------------------------------
    331          /// Transfers a data payload from an endpoint FIFO to the current transfer buffer
    332          /// \param bEndpoint Endpoint number.
    333          /// \param wPacketSize Size of received data packet
    334          //------------------------------------------------------------------------------
    335          static void UDP_ReadPayload(unsigned char bEndpoint, int wPacketSize)
    336          {
    337              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
    338              Transfer *pTransfer = &(pEndpoint->transfer);
    339          
    340              // Check that the requested size is not bigger than the remaining transfer
    341              if (wPacketSize > pTransfer->remaining) {
    342          
    343                  pTransfer->buffered += wPacketSize - pTransfer->remaining;
    344                  wPacketSize = pTransfer->remaining;
    345              }
    346          
    347              // Update transfer descriptor information
    348              pTransfer->remaining -= wPacketSize;
    349              pTransfer->transferred += wPacketSize;
    350          
    351              // Retrieve packet
    352              while (wPacketSize > 0) {
    353          
    354                  *(pTransfer->pData) = (char) AT91C_BASE_UDP->UDP_FDR[bEndpoint];
    355                  pTransfer->pData++;
    356                  wPacketSize--;
    357              }
    358          }
    359          
    360          //------------------------------------------------------------------------------
    361          /// Received SETUP packet from endpoint 0 FIFO
    362          /// \param pRequest Generic USB SETUP request sent over Control endpoints
    363          //------------------------------------------------------------------------------
    364          static void UDP_ReadRequest(USBGenericRequest *pRequest)
    365          {
    366              unsigned char *pData = (unsigned char *)pRequest;
    367              unsigned int i;
    368          
    369              // Copy packet
    370              for (i = 0; i < 8; i++) {
    371          
    372                  *pData = (unsigned char) AT91C_BASE_UDP->UDP_FDR[0];
    373                  pData++;
    374              }
    375          }
    376          
    377          //------------------------------------------------------------------------------
    378          /// Reset all endpoint transfer descriptors
    379          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    380          static void UDP_ResetEndpoints( void )
    381          {
   \                     UDP_ResetEndpoints:
   \   00000000   00402DE9           PUSH     {LR}
    382              Endpoint *pEndpoint;
    383              Transfer *pTransfer;
    384              unsigned char bEndpoint;
    385          
    386              // Reset the transfer descriptor of every endpoint
    387              for (bEndpoint = 0; bEndpoint < BOARD_USB_NUMENDPOINTS; bEndpoint++) {
   \   00000004   0000A0E3           MOV      R0,#+0
   \   00000008   0010E0E1           MVN      R1,R0
   \   0000000C   ........           LDR      R2,??DataTable16
    388          
    389                  pEndpoint = &(endpoints[bEndpoint]);
   \                     ??UDP_ResetEndpoints_0:
   \   00000010   1CC0A0E3           MOV      R12,#+28
   \   00000014   9C2023E0           MLA      R3,R12,R0,R2
    390                  pTransfer = &(pEndpoint->transfer);
   \   00000018   04C083E2           ADD      R12,R3,#+4
    391          
    392                  // Reset endpoint transfer descriptor
    393                  pTransfer->pData = 0;
   \   0000001C   00E0A0E3           MOV      LR,#+0
   \   00000020   00E08CE5           STR      LR,[R12, #+0]
    394                  pTransfer->transferred = -1;
   \   00000024   08108CE5           STR      R1,[R12, #+8]
    395                  pTransfer->buffered = -1;
   \   00000028   04108CE5           STR      R1,[R12, #+4]
    396                  pTransfer->remaining = -1;
   \   0000002C   0C108CE5           STR      R1,[R12, #+12]
    397                  pTransfer->fCallback = 0;
   \   00000030   10E08CE5           STR      LR,[R12, #+16]
    398                  pTransfer->pArgument = 0;
   \   00000034   14E08CE5           STR      LR,[R12, #+20]
    399          
    400                  // Reset endpoint state
    401                  pEndpoint->bank = 0;
   \   00000038   01E0C3E5           STRB     LR,[R3, #+1]
    402                  pEndpoint->state = UDP_ENDPOINT_DISABLED;
   \   0000003C   00E0C3E5           STRB     LR,[R3, #+0]
    403              }
   \   00000040   010080E2           ADD      R0,R0,#+1
   \   00000044   040050E3           CMP      R0,#+4
   \   00000048   F0FFFFBA           BLT      ??UDP_ResetEndpoints_0
    404          }
   \   0000004C                      REQUIRE ?Subroutine2
   \   0000004C                      ;; // Fall through to label ?Subroutine2
    405          
    406          //------------------------------------------------------------------------------
    407          /// Disable all endpoints (except control endpoint 0), aborting current 
    408          /// transfers if necessary
    409          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    410          static void UDP_DisableEndpoints( void )
    411          
    412          {
   \                     UDP_DisableEndpoints:
   \   00000000   38402DE9           PUSH     {R3-R5,LR}
    413              unsigned char bEndpoint;
    414          
    415              // Disable each endpoint, terminating any pending transfer
    416              // Control endpoint 0 is not disabled
    417              for (bEndpoint = 1; bEndpoint < BOARD_USB_NUMENDPOINTS; bEndpoint++) {
   \   00000004   0140A0E3           MOV      R4,#+1
   \   00000008   ........           LDR      R5,??DataTable16
    418          
    419                  UDP_EndOfTransfer(bEndpoint, USBD_STATUS_ABORTED);
   \                     ??UDP_DisableEndpoints_0:
   \   0000000C   0210A0E3           MOV      R1,#+2
   \   00000010   FF0004E2           AND      R0,R4,#0xFF
   \   00000014   ........           BL       UDP_EndOfTransfer
    420                  endpoints[bEndpoint].state = UDP_ENDPOINT_DISABLED;
   \   00000018   1C00A0E3           MOV      R0,#+28
   \   0000001C   905421E0           MLA      R1,R0,R4,R5
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   0000C1E5           STRB     R0,[R1, #+0]
    421              }
   \   00000028   014084E2           ADD      R4,R4,#+1
   \   0000002C   040054E3           CMP      R4,#+4
   \   00000030   F5FFFFBA           BLT      ??UDP_DisableEndpoints_0
    422          }
   \   00000034   3140BDE8           POP      {R0,R4,R5,LR}
   \   00000038   1EFF2FE1           BX       LR               ;; return
    423          
    424          //------------------------------------------------------------------------------
    425          /// Checks if an ongoing transfer on an endpoint has been completed.
    426          /// \param bEndpoint Endpoint number.
    427          /// \return 1 if the current transfer on the given endpoint is complete;
    428          ///         otherwise 0.
    429          //------------------------------------------------------------------------------
    430          static unsigned char UDP_IsTransferFinished(unsigned char bEndpoint)
    431          {
    432              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
    433              Transfer *pTransfer = &(pEndpoint->transfer);
    434          
    435              // Check if it is a Control endpoint
    436              //  -> Control endpoint must always finish their transfer with a zero-length
    437              //     packet
    438              if ((AT91C_BASE_UDP->UDP_CSR[bEndpoint] & AT91C_UDP_EPTYPE)
    439                  == AT91C_UDP_EPTYPE_CTRL) {
    440          
    441                  return (pTransfer->buffered < pEndpoint->size);
    442              }
    443              // Other endpoints only need to transfer all the data
    444              else {
    445          
    446                  return (pTransfer->buffered <= pEndpoint->size)
    447                         && (pTransfer->remaining == 0);
    448              }
    449          }
    450          
    451          //------------------------------------------------------------------------------
    452          /// Endpoint interrupt handler.
    453          /// Handle IN/OUT transfers, received SETUP packets and STALLing
    454          /// \param bEndpoint Index of endpoint
    455          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    456          static void UDP_EndpointHandler(unsigned char bEndpoint)
    457          {
   \                     UDP_EndpointHandler:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0040A0E1           MOV      R4,R0
    458              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   \   0000000C   0450A0E1           MOV      R5,R4
   \   00000010   1C00A0E3           MOV      R0,#+28
   \   00000014   ........           LDR      R1,??DataTable16
   \   00000018   901521E0           MLA      R1,R0,R5,R1
   \   0000001C   04108DE5           STR      R1,[SP, #+4]
   \   00000020   0160A0E1           MOV      R6,R1
    459              Transfer *pTransfer = &(pEndpoint->transfer);
   \   00000024   04B086E2           ADD      R11,R6,#+4
    460              unsigned int status = AT91C_BASE_UDP->UDP_CSR[bEndpoint];
   \   00000028   ........           LDR      R7,??DataTable16_1  ;; 0xfffb0030
   \   0000002C   058197E7           LDR      R8,[R7, +R5, LSL #+2]
   \   00000030   1C9047E2           SUB      R9,R7,#+28
   \   00000034   ........           LDR      R10,??DataTable16_3
   \   00000038   010018E3           TST      R8,#0x1
   \   0000003C   7400000A           BEQ      ??UDP_EndpointHandler_0
    461              unsigned short wPacketSize;
    462              USBGenericRequest request;
    463          
    464              TRACE_DEBUG_WP("E%d ", bEndpoint);
    465              TRACE_DEBUG_WP("st:0x%X ", status);
    466          
    467              // Handle interrupts
    468              // IN packet sent
    469              if ((status & AT91C_UDP_TXCOMP) != 0) {
    470          
    471                  TRACE_DEBUG_WP("Wr ");
    472          
    473                  // Check that endpoint was in Sending state
    474                  if (pEndpoint->state == UDP_ENDPOINT_SENDING) {
   \   00000040   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000044   030050E3           CMP      R0,#+3
   \   00000048   6200001A           BNE      ??UDP_EndpointHandler_1
    475          
    476                      // End of transfer ?
    477                      if (UDP_IsTransferFinished(bEndpoint)) {
   \   0000004C   0100A0E1           MOV      R0,R1
   \   00000050   041080E2           ADD      R1,R0,#+4
   \   00000054   052197E7           LDR      R2,[R7, +R5, LSL #+2]
   \   00000058   700E12E3           TST      R2,#0x700
   \   0000005C   2E00001A           BNE      ??UDP_EndpointHandler_2
   \   00000060   041091E5           LDR      R1,[R1, #+4]
   \   00000064   B200D0E1           LDRH     R0,[R0, #+2]
   \   00000068   000051E1           CMP      R1,R0
   \   0000006C   310000AA           BGE      ??UDP_EndpointHandler_3
    478          
    479                          pTransfer->transferred += pTransfer->buffered;
   \                     ??UDP_EndpointHandler_4:
   \   00000070   08009BE5           LDR      R0,[R11, #+8]
   \   00000074   04109BE5           LDR      R1,[R11, #+4]
   \   00000078   000081E0           ADD      R0,R1,R0
   \   0000007C   08008BE5           STR      R0,[R11, #+8]
    480                          pTransfer->buffered = 0;
   \   00000080   0000A0E3           MOV      R0,#+0
   \   00000084   04008BE5           STR      R0,[R11, #+4]
    481          
    482                          // Disable interrupt if this is not a control endpoint
    483                          if ((status & AT91C_UDP_EPTYPE) != AT91C_UDP_EPTYPE_CTRL) {
   \   00000088   700E18E3           TST      R8,#0x700
    484          
    485                              AT91C_BASE_UDP->UDP_IDR = 1 << bEndpoint;
   \   0000008C   0100A013           MOVNE    R0,#+1
   \   00000090   1004A011           LSLNE    R0,R0,R4
   \   00000094   00008915           STRNE    R0,[R9, #+0]
    486                          }
    487          
    488                          UDP_EndOfTransfer(bEndpoint, USBD_STATUS_SUCCESS);
   \   00000098   0010A0E3           MOV      R1,#+0
   \   0000009C   0400A0E1           MOV      R0,R4
   \   000000A0   ........           BL       UDP_EndOfTransfer
    489                          CLEAR_CSR(bEndpoint, AT91C_UDP_TXCOMP);
                                 ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \                     ??UDP_EndpointHandler_5:
   \   000000A4   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   000000A8   00008DE5           STR      R0,[SP, #+0]
   \   000000AC   00009DE5           LDR      R0,[SP, #+0]
   \   000000B0   4F0080E3           ORR      R0,R0,#0x4F
   \   000000B4   00008DE5           STR      R0,[SP, #+0]
   \   000000B8   00009DE5           LDR      R0,[SP, #+0]
   \   000000BC   0100C0E3           BIC      R0,R0,#0x1
   \   000000C0   00008DE5           STR      R0,[SP, #+0]
   \   000000C4   00009DE5           LDR      R0,[SP, #+0]
   \   000000C8   050187E7           STR      R0,[R7, +R5, LSL #+2]
   \                     ??UDP_EndpointHandler_6:
   \   000000CC   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   000000D0   010010E3           TST      R0,#0x1
   \   000000D4   FCFFFF1A           BNE      ??UDP_EndpointHandler_6
   \   000000D8   4D0000EA           B        ??UDP_EndpointHandler_0
    490                      }
    491                      else {
    492          
    493                          // Transfer remaining data
    494                          TRACE_DEBUG_WP(" %d ", pEndpoint->size);
    495          
    496                          pTransfer->transferred += pEndpoint->size;
    497                          pTransfer->buffered -= pEndpoint->size;
    498          
    499                          // Send next packet
    500                          if (BOARD_USB_ENDPOINTS_BANKS(bEndpoint) == 1) {
    501          
    502                              // No double buffering
    503                              UDP_WritePayload(bEndpoint);
   \                     ??UDP_EndpointHandler_7:
   \   000000DC   0400A0E1           MOV      R0,R4
   \   000000E0   ........           BL       UDP_WritePayload
    504                              SET_CSR(bEndpoint, AT91C_UDP_TXPKTRDY);
   \   000000E4   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   000000E8   00008DE5           STR      R0,[SP, #+0]
   \   000000EC   00009DE5           LDR      R0,[SP, #+0]
   \   000000F0   4F0080E3           ORR      R0,R0,#0x4F
   \   000000F4   00008DE5           STR      R0,[SP, #+0]
   \   000000F8   00009DE5           LDR      R0,[SP, #+0]
   \   000000FC   100080E3           ORR      R0,R0,#0x10
   \   00000100   00008DE5           STR      R0,[SP, #+0]
   \   00000104   00009DE5           LDR      R0,[SP, #+0]
   \   00000108   050187E7           STR      R0,[R7, +R5, LSL #+2]
   \                     ??UDP_EndpointHandler_8:
   \   0000010C   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   00000110   100010E3           TST      R0,#0x10
   \   00000114   FCFFFF0A           BEQ      ??UDP_EndpointHandler_8
    505                              CLEAR_CSR(bEndpoint, AT91C_UDP_TXCOMP);
                                     ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   00000118   E1FFFFEA           B        ??UDP_EndpointHandler_5
    506                          }
   \                     ??UDP_EndpointHandler_2:
   \   0000011C   B200D0E1           LDRH     R0,[R0, #+2]
   \   00000120   042091E5           LDR      R2,[R1, #+4]
   \   00000124   020050E1           CMP      R0,R2
   \   00000128   020000BA           BLT      ??UDP_EndpointHandler_3
   \   0000012C   0C0091E5           LDR      R0,[R1, #+12]
   \   00000130   000050E3           CMP      R0,#+0
   \   00000134   CDFFFF0A           BEQ      ??UDP_EndpointHandler_4
   \                     ??UDP_EndpointHandler_3:
   \   00000138   08009BE5           LDR      R0,[R11, #+8]
   \   0000013C   B210D6E1           LDRH     R1,[R6, #+2]
   \   00000140   000081E0           ADD      R0,R1,R0
   \   00000144   08008BE5           STR      R0,[R11, #+8]
   \   00000148   04009BE5           LDR      R0,[R11, #+4]
   \   0000014C   B210D6E1           LDRH     R1,[R6, #+2]
   \   00000150   010040E0           SUB      R0,R0,R1
   \   00000154   04008BE5           STR      R0,[R11, #+4]
   \   00000158   000054E3           CMP      R4,#+0
   \   0000015C   03005413           CMPNE    R4,#+3
   \   00000160   DDFFFF0A           BEQ      ??UDP_EndpointHandler_7
    507                          else {
    508                              // Double buffering
    509                              SET_CSR(bEndpoint, AT91C_UDP_TXPKTRDY);
   \   00000164   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   00000168   00008DE5           STR      R0,[SP, #+0]
   \   0000016C   00009DE5           LDR      R0,[SP, #+0]
   \   00000170   4F0080E3           ORR      R0,R0,#0x4F
   \   00000174   00008DE5           STR      R0,[SP, #+0]
   \   00000178   00009DE5           LDR      R0,[SP, #+0]
   \   0000017C   100080E3           ORR      R0,R0,#0x10
   \   00000180   00008DE5           STR      R0,[SP, #+0]
   \   00000184   00009DE5           LDR      R0,[SP, #+0]
   \   00000188   050187E7           STR      R0,[R7, +R5, LSL #+2]
   \                     ??UDP_EndpointHandler_9:
   \   0000018C   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   00000190   100010E3           TST      R0,#0x10
   \   00000194   FCFFFF0A           BEQ      ??UDP_EndpointHandler_9
    510                              CLEAR_CSR(bEndpoint, AT91C_UDP_TXCOMP);
                                     ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   00000198   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   0000019C   00008DE5           STR      R0,[SP, #+0]
   \   000001A0   00009DE5           LDR      R0,[SP, #+0]
   \   000001A4   4F0080E3           ORR      R0,R0,#0x4F
   \   000001A8   00008DE5           STR      R0,[SP, #+0]
   \   000001AC   00009DE5           LDR      R0,[SP, #+0]
   \   000001B0   0100C0E3           BIC      R0,R0,#0x1
   \   000001B4   00008DE5           STR      R0,[SP, #+0]
   \   000001B8   00009DE5           LDR      R0,[SP, #+0]
   \   000001BC   050187E7           STR      R0,[R7, +R5, LSL #+2]
   \                     ??UDP_EndpointHandler_10:
   \   000001C0   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   000001C4   010010E3           TST      R0,#0x1
   \   000001C8   FCFFFF1A           BNE      ??UDP_EndpointHandler_10
    511                              UDP_WritePayload(bEndpoint);
   \   000001CC   0400A0E1           MOV      R0,R4
   \   000001D0   ........           BL       UDP_WritePayload
   \   000001D4   0E0000EA           B        ??UDP_EndpointHandler_0
    512                          }
    513                      }
    514                  }
    515                  else {
    516                      // Acknowledge interrupt
    517                      TRACE_ERROR("Error Wr");
   \                     ??UDP_EndpointHandler_1:
   \   000001D8   0A00A0E1           MOV      R0,R10
   \   000001DC   ........           BL       printf
    518                      CLEAR_CSR(bEndpoint, AT91C_UDP_TXCOMP);
                             ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   000001E0   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   000001E4   00008DE5           STR      R0,[SP, #+0]
   \   000001E8   00009DE5           LDR      R0,[SP, #+0]
   \   000001EC   4F0080E3           ORR      R0,R0,#0x4F
   \   000001F0   00008DE5           STR      R0,[SP, #+0]
   \   000001F4   00009DE5           LDR      R0,[SP, #+0]
   \   000001F8   0100C0E3           BIC      R0,R0,#0x1
   \   000001FC   00008DE5           STR      R0,[SP, #+0]
   \   00000200   00009DE5           LDR      R0,[SP, #+0]
   \   00000204   050187E7           STR      R0,[R7, +R5, LSL #+2]
   \                     ??UDP_EndpointHandler_11:
   \   00000208   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   0000020C   010010E3           TST      R0,#0x1
   \   00000210   FCFFFF1A           BNE      ??UDP_EndpointHandler_11
    519                  }
    520              }
    521          
    522              // OUT packet received
    523              if ((status & UDP_RXDATA) != 0) {
   \                     ??UDP_EndpointHandler_0:
   \   00000214   420018E3           TST      R8,#0x42
   \   00000218   4000000A           BEQ      ??UDP_EndpointHandler_12
    524          
    525                  TRACE_DEBUG_WP("Rd ");
    526          
    527                  // Check that the endpoint is in Receiving state
    528                  if (pEndpoint->state != UDP_ENDPOINT_RECEIVING) {
   \   0000021C   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000220   040050E3           CMP      R0,#+4
   \   00000224   0E00000A           BEQ      ??UDP_EndpointHandler_13
    529          
    530                      // Check if an ACK has been received on a Control endpoint
    531                      if (((status & AT91C_UDP_EPTYPE) == AT91C_UDP_EPTYPE_CTRL)
    532                          && ((status & AT91C_UDP_RXBYTECNT) == 0)) {
   \   00000228   ........           LDR      R0,??DataTable16_4  ;; 0x7ff0700
   \   0000022C   080010E1           TST      R0,R8
   \   00000230   0200001A           BNE      ??UDP_EndpointHandler_14
    533          
    534                          // Acknowledge the data and finish the current transfer
    535                          UDP_ClearRxFlag(bEndpoint);
   \   00000234   0400A0E1           MOV      R0,R4
   \   00000238   ........           BL       UDP_ClearRxFlag
    536                          UDP_EndOfTransfer(bEndpoint, USBD_STATUS_SUCCESS);
   \   0000023C   340000EA           B        ??UDP_EndpointHandler_15
    537                      }
    538                      // Check if the data has been STALLed
    539                      else if ((status & AT91C_UDP_FORCESTALL) != 0) {
   \                     ??UDP_EndpointHandler_14:
   \   00000240   200018E3           TST      R8,#0x20
   \   00000244   0200000A           BEQ      ??UDP_EndpointHandler_16
    540          
    541                          // Discard STALLed data
    542                          TRACE_DEBUG_WP("Discard ");
    543                          UDP_ClearRxFlag(bEndpoint);
   \   00000248   0400A0E1           MOV      R0,R4
   \   0000024C   ........           BL       UDP_ClearRxFlag
   \   00000250   320000EA           B        ??UDP_EndpointHandler_12
    544                      }
    545                      // NAK the data
    546                      else {
    547          
    548                          TRACE_DEBUG_WP("Nak ");
    549                          AT91C_BASE_UDP->UDP_IDR = 1 << bEndpoint;
   \                     ??UDP_EndpointHandler_16:
   \   00000254   0100A0E3           MOV      R0,#+1
   \   00000258   1004A0E1           LSL      R0,R0,R4
   \   0000025C   000089E5           STR      R0,[R9, #+0]
   \   00000260   2E0000EA           B        ??UDP_EndpointHandler_12
    550                      }
    551                  }
    552                  // Endpoint is in Read state
    553                  else {
    554          
    555                      // Retrieve data and store it into the current transfer buffer
    556                      wPacketSize = (unsigned short) (status >> 16);
   \                     ??UDP_EndpointHandler_13:
   \   00000264   2808A0E1           LSR      R0,R8,#+16
   \   00000268   00008DE5           STR      R0,[SP, #+0]
    557                      TRACE_DEBUG_WP("%d ", wPacketSize);
    558                      UDP_ReadPayload(bEndpoint, wPacketSize);
   \   0000026C   0010A0E1           MOV      R1,R0
   \   00000270   04009DE5           LDR      R0,[SP, #+4]
   \   00000274   040080E2           ADD      R0,R0,#+4
   \   00000278   0C2090E5           LDR      R2,[R0, #+12]
   \   0000027C   010052E1           CMP      R2,R1
   \   00000280   050000AA           BGE      ??UDP_EndpointHandler_17
   \   00000284   042090E5           LDR      R2,[R0, #+4]
   \   00000288   021081E0           ADD      R1,R1,R2
   \   0000028C   0C2090E5           LDR      R2,[R0, #+12]
   \   00000290   021041E0           SUB      R1,R1,R2
   \   00000294   041080E5           STR      R1,[R0, #+4]
   \   00000298   0C1090E5           LDR      R1,[R0, #+12]
   \                     ??UDP_EndpointHandler_17:
   \   0000029C   0C2090E5           LDR      R2,[R0, #+12]
   \   000002A0   012042E0           SUB      R2,R2,R1
   \   000002A4   0C2080E5           STR      R2,[R0, #+12]
   \   000002A8   082090E5           LDR      R2,[R0, #+8]
   \   000002AC   022081E0           ADD      R2,R1,R2
   \   000002B0   082080E5           STR      R2,[R0, #+8]
   \   000002B4   070000EA           B        ??UDP_EndpointHandler_18
   \                     ??UDP_EndpointHandler_19:
   \   000002B8   202087E2           ADD      R2,R7,#+32
   \   000002BC   052192E7           LDR      R2,[R2, +R5, LSL #+2]
   \   000002C0   003090E5           LDR      R3,[R0, #+0]
   \   000002C4   0020C3E5           STRB     R2,[R3, #+0]
   \   000002C8   002090E5           LDR      R2,[R0, #+0]
   \   000002CC   012082E2           ADD      R2,R2,#+1
   \   000002D0   002080E5           STR      R2,[R0, #+0]
   \   000002D4   011041E2           SUB      R1,R1,#+1
   \                     ??UDP_EndpointHandler_18:
   \   000002D8   010051E3           CMP      R1,#+1
   \   000002DC   F5FFFFAA           BGE      ??UDP_EndpointHandler_19
    559                      UDP_ClearRxFlag(bEndpoint);
   \   000002E0   0400A0E1           MOV      R0,R4
   \   000002E4   ........           BL       UDP_ClearRxFlag
    560          
    561                      // Check if the transfer is finished
    562                      if ((pTransfer->remaining == 0) || (wPacketSize < pEndpoint->size)) {
   \   000002E8   0C009BE5           LDR      R0,[R11, #+12]
   \   000002EC   000050E3           CMP      R0,#+0
   \   000002F0   0300000A           BEQ      ??UDP_EndpointHandler_20
   \   000002F4   00009DE5           LDR      R0,[SP, #+0]
   \   000002F8   B210D6E1           LDRH     R1,[R6, #+2]
   \   000002FC   010050E1           CMP      R0,R1
   \   00000300   060000AA           BGE      ??UDP_EndpointHandler_12
    563          
    564                          // Disable interrupt if this is not a control endpoint
    565                          if ((status & AT91C_UDP_EPTYPE) != AT91C_UDP_EPTYPE_CTRL) {
   \                     ??UDP_EndpointHandler_20:
   \   00000304   700E18E3           TST      R8,#0x700
    566          
    567                              AT91C_BASE_UDP->UDP_IDR = 1 << bEndpoint;
   \   00000308   0100A013           MOVNE    R0,#+1
   \   0000030C   1004A011           LSLNE    R0,R0,R4
   \   00000310   00008915           STRNE    R0,[R9, #+0]
    568                          }
    569                          UDP_EndOfTransfer(bEndpoint, USBD_STATUS_SUCCESS);
   \                     ??UDP_EndpointHandler_15:
   \   00000314   0010A0E3           MOV      R1,#+0
   \   00000318   0400A0E1           MOV      R0,R4
   \   0000031C   ........           BL       UDP_EndOfTransfer
    570                      }
    571                  }
    572              }
    573          
    574              // STALL sent
    575              if ((status & AT91C_UDP_STALLSENT) != 0) {
   \                     ??UDP_EndpointHandler_12:
   \   00000320   080018E3           TST      R8,#0x8
   \   00000324   2200000A           BEQ      ??UDP_EndpointHandler_21
    576          
    577                  TRACE_WARNING( "Sta 0x%X [%d] ", status, bEndpoint);
   \   00000328   0520A0E1           MOV      R2,R5
   \   0000032C   0810A0E1           MOV      R1,R8
   \   00000330   10008AE2           ADD      R0,R10,#+16
   \   00000334   ........           BL       printf
    578          
    579                  // If the endpoint is not halted, clear the STALL condition
    580                  CLEAR_CSR(bEndpoint, AT91C_UDP_STALLSENT);
                         ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   00000338   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   0000033C   00008DE5           STR      R0,[SP, #+0]
   \   00000340   00009DE5           LDR      R0,[SP, #+0]
   \   00000344   4F0080E3           ORR      R0,R0,#0x4F
   \   00000348   00008DE5           STR      R0,[SP, #+0]
   \   0000034C   00009DE5           LDR      R0,[SP, #+0]
   \   00000350   0800C0E3           BIC      R0,R0,#0x8
   \   00000354   00008DE5           STR      R0,[SP, #+0]
   \   00000358   00009DE5           LDR      R0,[SP, #+0]
   \   0000035C   050187E7           STR      R0,[R7, +R5, LSL #+2]
   \                     ??UDP_EndpointHandler_22:
   \   00000360   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   00000364   080010E3           TST      R0,#0x8
   \   00000368   FCFFFF1A           BNE      ??UDP_EndpointHandler_22
    581                  if (pEndpoint->state != UDP_ENDPOINT_HALTED) {
   \   0000036C   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000370   010050E3           CMP      R0,#+1
   \   00000374   0E00000A           BEQ      ??UDP_EndpointHandler_21
    582          
    583                      TRACE_WARNING( "_ " );
   \   00000378   24008AE2           ADD      R0,R10,#+36
   \   0000037C   ........           BL       printf
    584                      CLEAR_CSR(bEndpoint, AT91C_UDP_FORCESTALL);
                             ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   00000380   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   00000384   00008DE5           STR      R0,[SP, #+0]
   \   00000388   00009DE5           LDR      R0,[SP, #+0]
   \   0000038C   4F0080E3           ORR      R0,R0,#0x4F
   \   00000390   00008DE5           STR      R0,[SP, #+0]
   \   00000394   00009DE5           LDR      R0,[SP, #+0]
   \   00000398   2000C0E3           BIC      R0,R0,#0x20
   \   0000039C   00008DE5           STR      R0,[SP, #+0]
   \   000003A0   00009DE5           LDR      R0,[SP, #+0]
   \   000003A4   050187E7           STR      R0,[R7, +R5, LSL #+2]
   \                     ??UDP_EndpointHandler_23:
   \   000003A8   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   000003AC   200010E3           TST      R0,#0x20
   \   000003B0   FCFFFF1A           BNE      ??UDP_EndpointHandler_23
    585                  }
    586              }
    587          
    588              // SETUP packet received
    589              if ((status & AT91C_UDP_RXSETUP) != 0) {
   \                     ??UDP_EndpointHandler_21:
   \   000003B4   040018E3           TST      R8,#0x4
   \   000003B8   2D00000A           BEQ      ??UDP_EndpointHandler_24
    590          
    591                  TRACE_DEBUG_WP("Stp ");
    592          
    593                  // If a transfer was pending, complete it
    594                  // Handles the case where during the status phase of a control write
    595                  // transfer, the host receives the device ZLP and ack it, but the ack
    596                  // is not received by the device
    597                  if ((pEndpoint->state == UDP_ENDPOINT_RECEIVING)
    598                      || (pEndpoint->state == UDP_ENDPOINT_SENDING)) {
   \   000003BC   0000D6E5           LDRB     R0,[R6, #+0]
   \   000003C0   040050E3           CMP      R0,#+4
   \   000003C4   0000D615           LDRBNE   R0,[R6, #+0]
   \   000003C8   03005013           CMPNE    R0,#+3
   \   000003CC   0200001A           BNE      ??UDP_EndpointHandler_25
    599          
    600                      UDP_EndOfTransfer(bEndpoint, USBD_STATUS_SUCCESS);
   \   000003D0   0010A0E3           MOV      R1,#+0
   \   000003D4   0400A0E1           MOV      R0,R4
   \   000003D8   ........           BL       UDP_EndOfTransfer
    601                  }
    602                  // Copy the setup packet
    603                  UDP_ReadRequest(&request);
   \                     ??UDP_EndpointHandler_25:
   \   000003DC   08008DE2           ADD      R0,SP,#+8
   \   000003E0   0810A0E3           MOV      R1,#+8
   \                     ??UDP_EndpointHandler_26:
   \   000003E4   3C2099E5           LDR      R2,[R9, #+60]
   \   000003E8   0120C0E4           STRB     R2,[R0], #+1
   \   000003EC   011051E2           SUBS     R1,R1,#+1
   \   000003F0   FBFFFF1A           BNE      ??UDP_EndpointHandler_26
    604          
    605                  // Set the DIR bit before clearing RXSETUP in Control IN sequence
    606                  if (USBGenericRequest_GetDirection(&request) == USBGenericRequest_IN) {
   \   000003F4   08008DE2           ADD      R0,SP,#+8
   \   000003F8   ........           BL       USBGenericRequest_GetDirection
   \   000003FC   010050E3           CMP      R0,#+1
   \   00000400   0C00001A           BNE      ??UDP_EndpointHandler_27
    607          
    608                      SET_CSR(bEndpoint, AT91C_UDP_DIR);
   \   00000404   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   00000408   00008DE5           STR      R0,[SP, #+0]
   \   0000040C   00009DE5           LDR      R0,[SP, #+0]
   \   00000410   4F0080E3           ORR      R0,R0,#0x4F
   \   00000414   00008DE5           STR      R0,[SP, #+0]
   \   00000418   00009DE5           LDR      R0,[SP, #+0]
   \   0000041C   800080E3           ORR      R0,R0,#0x80
   \   00000420   00008DE5           STR      R0,[SP, #+0]
   \   00000424   00009DE5           LDR      R0,[SP, #+0]
   \   00000428   050187E7           STR      R0,[R7, +R5, LSL #+2]
   \                     ??UDP_EndpointHandler_28:
   \   0000042C   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   00000430   800010E3           TST      R0,#0x80
   \   00000434   FCFFFF0A           BEQ      ??UDP_EndpointHandler_28
    609                  }
    610                  // Acknowledge setup packet
    611                  CLEAR_CSR(bEndpoint, AT91C_UDP_RXSETUP);
                         ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \                     ??UDP_EndpointHandler_27:
   \   00000438   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   0000043C   00008DE5           STR      R0,[SP, #+0]
   \   00000440   00009DE5           LDR      R0,[SP, #+0]
   \   00000444   4F0080E3           ORR      R0,R0,#0x4F
   \   00000448   00008DE5           STR      R0,[SP, #+0]
   \   0000044C   00009DE5           LDR      R0,[SP, #+0]
   \   00000450   0400C0E3           BIC      R0,R0,#0x4
   \   00000454   00008DE5           STR      R0,[SP, #+0]
   \   00000458   00009DE5           LDR      R0,[SP, #+0]
   \   0000045C   050187E7           STR      R0,[R7, +R5, LSL #+2]
   \                     ??UDP_EndpointHandler_29:
   \   00000460   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   00000464   040010E3           TST      R0,#0x4
   \   00000468   FCFFFF1A           BNE      ??UDP_EndpointHandler_29
    612          
    613                  // Forward the request to the upper layer
    614                  USBDCallbacks_RequestReceived(&request);
   \   0000046C   08008DE2           ADD      R0,SP,#+8
   \   00000470   ........           BL       USBDCallbacks_RequestReceived
    615              }
    616          
    617          }
   \                     ??UDP_EndpointHandler_24:
   \   00000474   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000478   F04FBDE8           POP      {R4-R11,LR}
   \   0000047C   1EFF2FE1           BX       LR               ;; return
    618          
    619          //------------------------------------------------------------------------------
    620          //      Exported functions
    621          //------------------------------------------------------------------------------
    622          //------------------------------------------------------------------------------
    623          /// USB interrupt handler
    624          /// Manages device resume, suspend, end of bus reset. 
    625          /// Forwards endpoint interrupts to the appropriate handler.
    626          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    627          void UDPD_IrqHandler(void)
    628          {
   \                     UDPD_IrqHandler:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
    629              unsigned int status;
    630              int eptnum = 0;
   \   00000004   0040A0E3           MOV      R4,#+0
    631              
    632              // Get interrupt status
    633              // Some interrupts may get masked depending on the device state
    634              status = AT91C_BASE_UDP->UDP_ISR;
   \   00000008   ........           LDR      R5,??DataTable16_5  ;; 0xfffb0010
   \   0000000C   0C0095E5           LDR      R0,[R5, #+12]
    635              status &= AT91C_BASE_UDP->UDP_IMR;
   \   00000010   081095E5           LDR      R1,[R5, #+8]
   \   00000014   006001E0           AND      R6,R1,R0
    636          
    637              if (deviceState < USBD_STATE_POWERED) {
   \   00000018   ........           LDR      R7,??DataTable16_6
   \   0000001C   0000D7E5           LDRB     R0,[R7, #+0]
   \   00000020   020050E3           CMP      R0,#+2
    638          
    639                  status &= AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM;
   \   00000024   886D0632           ANDCC    R6,R6,#0x2200
    640                  AT91C_BASE_UDP->UDP_ICR = ~status;
   \   00000028   0610E031           MVNCC    R1,R6
   \   0000002C   10108535           STRCC    R1,[R5, #+16]
    641              }
    642          
    643              // Return immediately if there is no interrupt to service
    644              if (status == 0) {
   \   00000030   000056E3           CMP      R6,#+0
   \   00000034   4F00000A           BEQ      ??UDPD_IrqHandler_0
    645          
    646                  TRACE_DEBUG_WP(".\n\r");
    647                  return;
    648              }
    649          
    650              // Toggle USB LED if the device is active
    651              if (deviceState >= USBD_STATE_POWERED) {
   \   00000038   020050E3           CMP      R0,#+2
   \   0000003C   0100003A           BCC      ??UDPD_IrqHandler_1
    652          
    653                  LED_Set(USBD_LEDUSB);
   \   00000040   0100A0E3           MOV      R0,#+1
   \   00000044   ........           BL       LED_Set
    654              }
    655          
    656              // Service interrupts
    657          
    658              //// Start Of Frame (SOF)
    659              //if (ISSET(dStatus, AT91C_UDP_SOFINT)) {
    660              //
    661              //    TRACE_DEBUG("SOF");
    662              //
    663              //    // Invoke the SOF callback
    664              //    USB_StartOfFrameCallback(pUsb);
    665              //
    666              //    // Acknowledge interrupt
    667              //    AT91C_BASE_UDP->UDP_ICR = AT91C_UDP_SOFINT;
    668              //    dStatus &= ~AT91C_UDP_SOFINT;
    669              //}
    670          
    671              // Suspend
    672              // This interrupt is always treated last (hence the '==')
    673              if (status == AT91C_UDP_RXSUSP) {
   \                     ??UDPD_IrqHandler_1:
   \   00000048   0000D7E5           LDRB     R0,[R7, #+0]
   \   0000004C   808EA0E3           MOV      R8,#+2048
   \   00000050   409FA0E3           MOV      R9,#+256
   \   00000054   88ADA0E3           MOV      R10,#+8704
   \   00000058   400F56E3           CMP      R6,#+256
   \   0000005C   0F00001A           BNE      ??UDPD_IrqHandler_2
    674          
    675                  TRACE_INFO_WP("Susp ");
    676          
    677                  // Don't do anything if the device is already suspended
    678                  if (deviceState != USBD_STATE_SUSPENDED) {
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   4300000A           BEQ      ??UDPD_IrqHandler_0
    679          
    680                      // The device enters the Suspended state
    681                      // Enable wakeup
    682                      AT91C_BASE_UDP->UDP_IER = AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM;
   \   00000068   00A085E5           STR      R10,[R5, #+0]
    683          
    684                      // Acknowledge interrupt
    685                      AT91C_BASE_UDP->UDP_ICR = AT91C_UDP_RXSUSP;
   \   0000006C   109085E5           STR      R9,[R5, #+16]
    686          
    687                      // Switch to the Suspended state
    688                      previousDeviceState = deviceState;
   \   00000070   0100C7E5           STRB     R0,[R7, #+1]
    689                      deviceState = USBD_STATE_SUSPENDED;
   \   00000074   0040C7E5           STRB     R4,[R7, #+0]
    690                      // Invoke the Suspended callback
    691                      USBDCallbacks_Suspended();
   \   00000078   ........           BL       USBDCallbacks_Suspended
    692                      UDP_DisableTransceiver();
   \   0000007C   640095E5           LDR      R0,[R5, #+100]
   \   00000080   400F80E3           ORR      R0,R0,#0x100
   \   00000084   640085E5           STR      R0,[R5, #+100]
    693                      UDP_DisablePeripheralClock();
   \   00000088   1400A0E3           MOV      R0,#+20
   \   0000008C   008400E5           STR      R8,[R0, #-1024]
    694                      UDP_DisableUsbClock();
   \   00000090   0400A0E3           MOV      R0,#+4
   \   00000094   8010A0E3           MOV      R1,#+128
   \   00000098   001400E5           STR      R1,[R0, #-1024]
    695                  }
    696              }
   \   0000009C   300000EA           B        ??UDPD_IrqHandler_3
    697              // Resume
    698              else if ((status & (AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM)) != 0) {
   \                     ??UDPD_IrqHandler_2:
   \   000000A0   8CBDA0E3           MOV      R11,#+8960
   \   000000A4   880D16E3           TST      R6,#0x2200
   \   000000A8   1200000A           BEQ      ??UDPD_IrqHandler_4
    699          
    700                  TRACE_INFO_WP("Res ");
    701          
    702                  // Don't do anything if the device was not suspended
    703                  if (deviceState == USBD_STATE_SUSPENDED) {
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   0D00001A           BNE      ??UDPD_IrqHandler_5
    704          
    705                      // The device enters its previous state
    706                      UDP_EnablePeripheralClock();
   \   000000B4   1000A0E3           MOV      R0,#+16
   \   000000B8   008400E5           STR      R8,[R0, #-1024]
    707                      UDP_EnableUsbClock();
   \   000000BC   FF00E0E3           MVN      R0,#+255
   \   000000C0   C00FC0E3           BIC      R0,R0,#0x300
   \   000000C4   8010A0E3           MOV      R1,#+128
   \   000000C8   001080E5           STR      R1,[R0, #+0]
    708          
    709                      // Enable the transceiver if the device was past the Default
    710                      // state
    711                      deviceState = previousDeviceState;
   \   000000CC   0100D7E5           LDRB     R0,[R7, #+1]
   \   000000D0   0000C7E5           STRB     R0,[R7, #+0]
    712                      if (deviceState >= USBD_STATE_DEFAULT) {
   \   000000D4   030050E3           CMP      R0,#+3
   \   000000D8   0300003A           BCC      ??UDPD_IrqHandler_5
    713          
    714                          UDP_EnableTransceiver();
   \   000000DC   640095E5           LDR      R0,[R5, #+100]
   \   000000E0   400FC0E3           BIC      R0,R0,#0x100
   \   000000E4   640085E5           STR      R0,[R5, #+100]
    715          
    716                          // Invoke the Resume callback
    717                          USBDCallbacks_Resumed();
   \   000000E8   ........           BL       USBDCallbacks_Resumed
    718                      }
    719                  }
    720                  
    721                  // Clear and disable resume interrupts
    722                  AT91C_BASE_UDP->UDP_ICR = AT91C_UDP_WAKEUP 
    723                                            | AT91C_UDP_RXRSM
    724                                            | AT91C_UDP_RXSUSP;
   \                     ??UDPD_IrqHandler_5:
   \   000000EC   10B085E5           STR      R11,[R5, #+16]
    725                  AT91C_BASE_UDP->UDP_IDR = AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM;
   \   000000F0   04A085E5           STR      R10,[R5, #+4]
   \   000000F4   1A0000EA           B        ??UDPD_IrqHandler_3
    726              }
    727              // End of bus reset
    728              else if ((status & AT91C_UDP_ENDBUSRES) != 0) {
   \                     ??UDPD_IrqHandler_4:
   \   000000F8   400D16E3           TST      R6,#0x1000
   \   000000FC   0E00000A           BEQ      ??UDPD_IrqHandler_6
    729          
    730                  TRACE_INFO_WP("EoBRes ");
    731          
    732                  // The device enters the Default state
    733                  deviceState = USBD_STATE_DEFAULT;
   \   00000100   0300A0E3           MOV      R0,#+3
   \   00000104   0000C7E5           STRB     R0,[R7, #+0]
    734                  UDP_EnableTransceiver();
   \   00000108   640095E5           LDR      R0,[R5, #+100]
   \   0000010C   400FC0E3           BIC      R0,R0,#0x100
   \   00000110   640085E5           STR      R0,[R5, #+100]
    735                  UDP_ResetEndpoints();
   \   00000114   ........           BL       UDP_ResetEndpoints
    736                  UDP_DisableEndpoints();
   \   00000118   ........           BL       UDP_DisableEndpoints
    737                  USBD_ConfigureEndpoint(0);
   \   0000011C   0000A0E3           MOV      R0,#+0
   \   00000120   ........           BL       USBD_ConfigureEndpoint
    738          
    739                  // Flush and enable the Suspend interrupt
    740                  AT91C_BASE_UDP->UDP_ICR = AT91C_UDP_WAKEUP
    741                                            | AT91C_UDP_RXRSM
    742                                            | AT91C_UDP_RXSUSP;
   \   00000124   10B085E5           STR      R11,[R5, #+16]
    743                  AT91C_BASE_UDP->UDP_IER = AT91C_UDP_RXSUSP;
   \   00000128   009085E5           STR      R9,[R5, #+0]
    744          
    745                  //// Enable the Start Of Frame (SOF) interrupt if needed
    746                  //if (pUsb->pCallbacks->startOfFrame != 0) {
    747                  //
    748                  //    AT91C_BASE_UDP->UDP_IER = AT91C_UDP_SOFINT;
    749                  //}
    750          
    751                  // Invoke the Reset callback
    752                  USBDCallbacks_Reset();
   \   0000012C   ........           BL       USBDCallbacks_Reset
    753          
    754                  // Acknowledge end of bus reset interrupt
    755                  AT91C_BASE_UDP->UDP_ICR = AT91C_UDP_ENDBUSRES;
   \   00000130   400DA0E3           MOV      R0,#+4096
   \   00000134   100085E5           STR      R0,[R5, #+16]
   \   00000138   090000EA           B        ??UDPD_IrqHandler_3
    756              }
   \                     ??UDPD_IrqHandler_6:
   \   0000013C   0100A0E3           MOV      R0,#+1
   \   00000140   1054A0E1           LSL      R5,R0,R4
   \   00000144   060015E1           TST      R5,R6
   \   00000148   0200000A           BEQ      ??UDPD_IrqHandler_7
    757              // Endpoint interrupts
    758              else {
    759          
    760                  while (status != 0) {
    761          
    762                      // Check if endpoint has a pending interrupt
    763                      if ((status & (1 << eptnum)) != 0) {
    764                      
    765                          UDP_EndpointHandler(eptnum);
   \   0000014C   FF0004E2           AND      R0,R4,#0xFF
   \   00000150   ........           BL       UDP_EndpointHandler
    766                          status &= ~(1 << eptnum);
   \   00000154   0560C6E1           BIC      R6,R6,R5
    767                          
    768                          if (status != 0) {
    769                          
    770                              TRACE_INFO_WP("\n\r  - ");
    771                          }
    772                      }
    773                      eptnum++;
   \                     ??UDPD_IrqHandler_7:
   \   00000158   014084E2           ADD      R4,R4,#+1
    774                  }
   \   0000015C   000056E3           CMP      R6,#+0
   \   00000160   F5FFFF1A           BNE      ??UDPD_IrqHandler_6
    775              }
    776          
    777              // Toggle LED back to its previous state
    778              TRACE_DEBUG_WP("!");
    779              TRACE_INFO_WP("\n\r");
    780              if (deviceState >= USBD_STATE_POWERED) {
   \                     ??UDPD_IrqHandler_3:
   \   00000164   0000D7E5           LDRB     R0,[R7, #+0]
   \   00000168   020050E3           CMP      R0,#+2
   \   0000016C   0100003A           BCC      ??UDPD_IrqHandler_0
    781          
    782                  LED_Clear(USBD_LEDUSB);
   \   00000170   0100A0E3           MOV      R0,#+1
   \   00000174   ........           BL       LED_Clear
   \                     ??UDPD_IrqHandler_0:
   \   00000178   F14FBDE8           POP      {R0,R4-R11,LR}
   \   0000017C   1EFF2FE1           BX       LR               ;; return
    783              }
    784          }
    785          
    786          //------------------------------------------------------------------------------
    787          /// Configures an endpoint according to its Endpoint Descriptor.
    788          /// \param pDescriptor Pointer to an Endpoint descriptor.
    789          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    790          void USBD_ConfigureEndpoint(const USBEndpointDescriptor *pDescriptor)
    791          {
   \                     USBD_ConfigureEndpoint:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0080B0E1           MOVS     R8,R0
    792              Endpoint *pEndpoint;
    793              unsigned char bEndpoint;
    794              unsigned char bType;
    795              unsigned char bEndpointDir;
    796          
    797              // NULL descriptor -> Control endpoint 0
    798              if (pDescriptor == 0) {
   \   0000000C   ........           LDR      R7,??DataTable16
    799          
    800                  bEndpoint = 0;
   \   00000010   0040A003           MOVEQ    R4,#+0
    801                  pEndpoint = &(endpoints[bEndpoint]);
    802                  bType= USBEndpointDescriptor_CONTROL;
   \   00000014   0050A003           MOVEQ    R5,#+0
    803                  bEndpointDir = 0;
   \   00000018   0060A003           MOVEQ    R6,#+0
    804                  pEndpoint->size = BOARD_USB_ENDPOINTS_MAXPACKETSIZE(0);
   \   0000001C   0800A003           MOVEQ    R0,#+8
   \   00000020   0B00000A           BEQ      ??USBD_ConfigureEndpoint_0
    805              }
    806              else {
    807          
    808                  bEndpoint = USBEndpointDescriptor_GetNumber(pDescriptor);
   \   00000024   ........           BL       USBEndpointDescriptor_GetNumber
   \   00000028   0040A0E1           MOV      R4,R0
    809                  pEndpoint = &(endpoints[bEndpoint]);
   \   0000002C   1C00A0E3           MOV      R0,#+28
   \   00000030   907427E0           MLA      R7,R0,R4,R7
    810                  bType = USBEndpointDescriptor_GetType(pDescriptor);
   \   00000034   0800A0E1           MOV      R0,R8
   \   00000038   ........           BL       USBEndpointDescriptor_GetType
   \   0000003C   0050A0E1           MOV      R5,R0
    811                  bEndpointDir = USBEndpointDescriptor_GetDirection(pDescriptor);
   \   00000040   0800A0E1           MOV      R0,R8
   \   00000044   ........           BL       USBEndpointDescriptor_GetDirection
   \   00000048   0060A0E1           MOV      R6,R0
    812                  pEndpoint->size = USBEndpointDescriptor_GetMaxPacketSize(pDescriptor);
   \   0000004C   0800A0E1           MOV      R0,R8
   \   00000050   ........           BL       USBEndpointDescriptor_GetMaxPacketSize
   \                     ??USBD_ConfigureEndpoint_0:
   \   00000054   B200C7E1           STRH     R0,[R7, #+2]
    813              }
    814          
    815              // Abort the current transfer is the endpoint was configured and in
    816              // Write or Read state
    817              if ((pEndpoint->state == UDP_ENDPOINT_RECEIVING)
    818                  || (pEndpoint->state == UDP_ENDPOINT_SENDING)) {
   \   00000058   0000D7E5           LDRB     R0,[R7, #+0]
   \   0000005C   040050E3           CMP      R0,#+4
   \   00000060   0000D715           LDRBNE   R0,[R7, #+0]
   \   00000064   03005013           CMPNE    R0,#+3
   \   00000068   0200001A           BNE      ??USBD_ConfigureEndpoint_1
    819          
    820                  UDP_EndOfTransfer(bEndpoint, USBD_STATUS_RESET);
   \   0000006C   0310A0E3           MOV      R1,#+3
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   ........           BL       UDP_EndOfTransfer
    821              }
    822              pEndpoint->state = UDP_ENDPOINT_IDLE;
   \                     ??USBD_ConfigureEndpoint_1:
   \   00000078   0200A0E3           MOV      R0,#+2
   \   0000007C   0000C7E5           STRB     R0,[R7, #+0]
    823          
    824              // Reset Endpoint Fifos
    825              AT91C_BASE_UDP->UDP_RSTEP |= (1 << bEndpoint);
   \   00000080   0100A0E3           MOV      R0,#+1
   \   00000084   1004A0E1           LSL      R0,R0,R4
   \   00000088   ........           LDR      R1,??DataTable16_5  ;; 0xfffb0010
   \   0000008C   182091E5           LDR      R2,[R1, #+24]
   \   00000090   022080E1           ORR      R2,R0,R2
   \   00000094   182081E5           STR      R2,[R1, #+24]
    826              AT91C_BASE_UDP->UDP_RSTEP &= ~(1 << bEndpoint);
   \   00000098   182091E5           LDR      R2,[R1, #+24]
   \   0000009C   0020C2E1           BIC      R2,R2,R0
   \   000000A0   182081E5           STR      R2,[R1, #+24]
    827          
    828              // Configure endpoint
    829              SET_CSR(bEndpoint, (unsigned int)AT91C_UDP_EPEDS
    830                                  | (bType << 8) | (bEndpointDir << 10));
   \   000000A4   202081E3           ORR      R2,R1,#0x20
   \   000000A8   043192E7           LDR      R3,[R2, +R4, LSL #+2]
   \   000000AC   00308DE5           STR      R3,[SP, #+0]
   \   000000B0   00309DE5           LDR      R3,[SP, #+0]
   \   000000B4   4F3083E3           ORR      R3,R3,#0x4F
   \   000000B8   00308DE5           STR      R3,[SP, #+0]
   \   000000BC   0635A0E1           LSL      R3,R6,#+10
   \   000000C0   00E09DE5           LDR      LR,[SP, #+0]
   \   000000C4   056483E1           ORR      R6,R3,R5, LSL #+8
   \   000000C8   806C86E3           ORR      R6,R6,#0x8000
   \   000000CC   0EE086E1           ORR      LR,R6,LR
   \   000000D0   00E08DE5           STR      LR,[SP, #+0]
   \   000000D4   00E09DE5           LDR      LR,[SP, #+0]
   \   000000D8   04E182E7           STR      LR,[R2, +R4, LSL #+2]
   \   000000DC   053483E1           ORR      R3,R3,R5, LSL #+8
   \   000000E0   803C83E3           ORR      R3,R3,#0x8000
   \                     ??USBD_ConfigureEndpoint_2:
   \   000000E4   04C192E7           LDR      R12,[R2, +R4, LSL #+2]
   \   000000E8   0CC003E0           AND      R12,R3,R12
   \   000000EC   03005CE1           CMP      R12,R3
   \   000000F0   FBFFFF1A           BNE      ??USBD_ConfigureEndpoint_2
    831              if (bType != USBEndpointDescriptor_CONTROL) {
   \   000000F4   000055E3           CMP      R5,#+0
    832          
    833              }
    834              else {
    835          
    836                  AT91C_BASE_UDP->UDP_IER = (1 << bEndpoint);
   \   000000F8   00008105           STREQ    R0,[R1, #+0]
    837              }
    838          
    839              TRACE_INFO_WP("CfgEpt%d ", bEndpoint);
    840          }
   \   000000FC   F341BDE8           POP      {R0,R1,R4-R8,LR}
   \   00000100   1EFF2FE1           BX       LR               ;; return
    841          
    842          //------------------------------------------------------------------------------
    843          /// Sends data through a USB endpoint. Sets up the transfer descriptor,
    844          /// writes one or two data payloads (depending on the number of FIFO bank
    845          /// for the endpoint) and then starts the actual transfer. The operation is
    846          /// complete when all the data has been sent.
    847          ///
    848          /// *If the size of the buffer is greater than the size of the endpoint
    849          ///  (or twice the size if the endpoint has two FIFO banks), then the buffer
    850          ///  must be kept allocated until the transfer is finished*. This means that
    851          ///  it is not possible to declare it on the stack (i.e. as a local variable
    852          ///  of a function which returns after starting a transfer).
    853          ///
    854          /// \param bEndpoint Endpoint number.
    855          /// \param pData Pointer to a buffer with the data to send.
    856          /// \param dLength Size of the data buffer.
    857          /// \param fCallback Optional callback function to invoke when the transfer is
    858          ///        complete.
    859          /// \param pArgument Optional argument to the callback function.
    860          /// \return USBD_STATUS_SUCCESS if the transfer has been started;
    861          ///         otherwise, the corresponding error status code.
    862          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    863          char USBD_Write( unsigned char    bEndpoint,
    864                           const void       *pData,
    865                           unsigned int     dLength,
    866                           TransferCallback fCallback,
    867                           void             *pArgument )
    868          {
   \                     USBD_Write:
   \   00000000   F8402DE9           PUSH     {R3-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   18009DE5           LDR      R0,[SP, #+24]
    869              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   \   0000000C   0450A0E1           MOV      R5,R4
   \   00000010   1CE0A0E3           MOV      LR,#+28
   \   00000014   ........           LDR      R12,??DataTable16
   \   00000018   9EC52CE0           MLA      R12,LR,R5,R12
    870              Transfer *pTransfer = &(pEndpoint->transfer);
   \   0000001C   04608CE2           ADD      R6,R12,#+4
    871          
    872              // Check that the endpoint is in Idle state
    873              if (pEndpoint->state != UDP_ENDPOINT_IDLE) {
   \   00000020   00E0DCE5           LDRB     LR,[R12, #+0]
   \   00000024   02005EE3           CMP      LR,#+2
    874          
    875                  return USBD_STATUS_LOCKED;
   \   00000028   0100A013           MOVNE    R0,#+1
   \   0000002C   2800001A           BNE      ??USBD_Write_0
    876              }
    877              TRACE_DEBUG_WP("Write%d(%d) ", bEndpoint, dLength);
    878          
    879              // Setup the transfer descriptor
    880              pTransfer->pData = (void *) pData;
   \   00000030   001086E5           STR      R1,[R6, #+0]
    881              pTransfer->remaining = dLength;
   \   00000034   0C2086E5           STR      R2,[R6, #+12]
    882              pTransfer->buffered = 0;
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   041086E5           STR      R1,[R6, #+4]
    883              pTransfer->transferred = 0;
   \   00000040   081086E5           STR      R1,[R6, #+8]
    884              pTransfer->fCallback = fCallback;
   \   00000044   103086E5           STR      R3,[R6, #+16]
    885              pTransfer->pArgument = pArgument;
   \   00000048   140086E5           STR      R0,[R6, #+20]
    886          
    887              // Send the first packet
    888              pEndpoint->state = UDP_ENDPOINT_SENDING;
   \   0000004C   0300A0E3           MOV      R0,#+3
   \   00000050   0000CCE5           STRB     R0,[R12, #+0]
   \   00000054   ........           LDR      R7,??DataTable16_1  ;; 0xfffb0030
    889              while((AT91C_BASE_UDP->UDP_CSR[bEndpoint]&AT91C_UDP_TXPKTRDY)==AT91C_UDP_TXPKTRDY);
   \                     ??USBD_Write_1:
   \   00000058   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   0000005C   100010E3           TST      R0,#0x10
   \   00000060   FCFFFF1A           BNE      ??USBD_Write_1
    890              UDP_WritePayload(bEndpoint);
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           BL       UDP_WritePayload
    891              SET_CSR(bEndpoint, AT91C_UDP_TXPKTRDY);
   \   0000006C   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   00000070   00008DE5           STR      R0,[SP, #+0]
   \   00000074   00009DE5           LDR      R0,[SP, #+0]
   \   00000078   4F0080E3           ORR      R0,R0,#0x4F
   \   0000007C   00008DE5           STR      R0,[SP, #+0]
   \   00000080   00009DE5           LDR      R0,[SP, #+0]
   \   00000084   100080E3           ORR      R0,R0,#0x10
   \   00000088   00008DE5           STR      R0,[SP, #+0]
   \   0000008C   00009DE5           LDR      R0,[SP, #+0]
   \   00000090   050187E7           STR      R0,[R7, +R5, LSL #+2]
   \                     ??USBD_Write_2:
   \   00000094   050197E7           LDR      R0,[R7, +R5, LSL #+2]
   \   00000098   100010E3           TST      R0,#0x10
   \   0000009C   FCFFFF0A           BEQ      ??USBD_Write_2
    892          
    893              // If double buffering is enabled and there is data remaining,
    894              // prepare another packet
    895              if ((BOARD_USB_ENDPOINTS_BANKS(bEndpoint) > 1) && (pTransfer->remaining > 0)) {
   \   000000A0   000054E3           CMP      R4,#+0
   \   000000A4   03005413           CMPNE    R4,#+3
   \   000000A8   0400000A           BEQ      ??USBD_Write_3
   \   000000AC   0C0096E5           LDR      R0,[R6, #+12]
   \   000000B0   010050E3           CMP      R0,#+1
   \   000000B4   010000BA           BLT      ??USBD_Write_3
    896          
    897                  UDP_WritePayload(bEndpoint);
   \   000000B8   0400A0E1           MOV      R0,R4
   \   000000BC   ........           BL       UDP_WritePayload
    898              }
    899          
    900              // Enable interrupt on endpoint
    901              AT91C_BASE_UDP->UDP_IER = 1 << bEndpoint;
   \                     ??USBD_Write_3:
   \   000000C0   0100A0E3           MOV      R0,#+1
   \   000000C4   1004A0E1           LSL      R0,R0,R4
   \   000000C8   2010C7E3           BIC      R1,R7,#0x20
   \   000000CC   000081E5           STR      R0,[R1, #+0]
    902          
    903              return USBD_STATUS_SUCCESS;
   \   000000D0   0000A0E3           MOV      R0,#+0
   \                     ??USBD_Write_0:
   \   000000D4   F240BDE8           POP      {R1,R4-R7,LR}
   \   000000D8   1EFF2FE1           BX       LR               ;; return
    904          }
    905          
    906          
    907          //------------------------------------------------------------------------------
    908          /// Reads incoming data on an USB endpoint This methods sets the transfer
    909          /// descriptor and activate the endpoint interrupt. The actual transfer is
    910          /// then carried out by the endpoint interrupt handler. The Read operation
    911          /// finishes either when the buffer is full, or a short packet (inferior to
    912          /// endpoint maximum  size) is received.
    913          ///
    914          /// *The buffer must be kept allocated until the transfer is finished*.
    915          /// \param bEndpoint Endpoint number.
    916          /// \param pData Pointer to a data buffer.
    917          /// \param dLength Size of the data buffer in bytes.
    918          /// \param fCallback Optional end-of-transfer callback function.
    919          /// \param pArgument Optional argument to the callback function.
    920          /// \return USBD_STATUS_SUCCESS if the read operation has been started;
    921          ///         otherwise, the corresponding error code.
    922          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    923          char USBD_Read(unsigned char    bEndpoint,
    924                         void             *pData,
    925                         unsigned int     dLength,
    926                         TransferCallback fCallback,
    927                         void             *pArgument)
    928          {
   \                     USBD_Read:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0CC09DE5           LDR      R12,[SP, #+12]
    929              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   \   00000008   00E0A0E1           MOV      LR,R0
   \   0000000C   1C40A0E3           MOV      R4,#+28
   \   00000010   ........           LDR      R5,??DataTable16
   \   00000014   945E2EE0           MLA      LR,R4,LR,R5
    930              Transfer *pTransfer = &(pEndpoint->transfer);
   \   00000018   04408EE2           ADD      R4,LR,#+4
    931          
    932              // Return if the endpoint is not in IDLE state
    933              if (pEndpoint->state != UDP_ENDPOINT_IDLE) {
   \   0000001C   0050DEE5           LDRB     R5,[LR, #+0]
   \   00000020   020055E3           CMP      R5,#+2
    934          
    935                  return USBD_STATUS_LOCKED;
   \   00000024   0100A013           MOVNE    R0,#+1
   \   00000028   0D00001A           BNE      ??USBD_Read_0
    936              }
    937          
    938              // Endpoint enters Receiving state
    939              pEndpoint->state = UDP_ENDPOINT_RECEIVING;
   \   0000002C   0450A0E3           MOV      R5,#+4
   \   00000030   0050CEE5           STRB     R5,[LR, #+0]
    940              TRACE_DEBUG_WP("Read%d(%d) ", bEndpoint, dLength);
    941          
    942              // Set the transfer descriptor
    943              pTransfer->pData = pData;
   \   00000034   001084E5           STR      R1,[R4, #+0]
    944              pTransfer->remaining = dLength;
   \   00000038   0C2084E5           STR      R2,[R4, #+12]
    945              pTransfer->buffered = 0;
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   041084E5           STR      R1,[R4, #+4]
    946              pTransfer->transferred = 0;
   \   00000044   081084E5           STR      R1,[R4, #+8]
    947              pTransfer->fCallback = fCallback;
   \   00000048   103084E5           STR      R3,[R4, #+16]
    948              pTransfer->pArgument = pArgument;
   \   0000004C   14C084E5           STR      R12,[R4, #+20]
    949          
    950              // Enable interrupt on endpoint
    951              AT91C_BASE_UDP->UDP_IER = 1 << bEndpoint;
   \   00000050   0110A0E3           MOV      R1,#+1
   \   00000054   1100A0E1           LSL      R0,R1,R0
   \   00000058   ........           LDR      R1,??DataTable16_5  ;; 0xfffb0010
   \   0000005C   000081E5           STR      R0,[R1, #+0]
    952          
    953              return USBD_STATUS_SUCCESS;
   \   00000060   0000A0E3           MOV      R0,#+0
   \                     ??USBD_Read_0:
   \   00000064   3040BDE8           POP      {R4,R5,LR}
   \   00000068   1EFF2FE1           BX       LR               ;; return
    954          }
    955          
    956          //------------------------------------------------------------------------------
    957          /// Sets the HALT feature on the given endpoint (if not already in this state).
    958          /// \param bEndpoint Endpoint number.
    959          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    960          void USBD_Halt(unsigned char bEndpoint)
    961          {
   \                     USBD_Halt:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0040A0E1           MOV      R4,R0
    962              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   \   0000000C   0450A0E1           MOV      R5,R4
   \   00000010   1C00A0E3           MOV      R0,#+28
   \   00000014   ........           LDR      R1,??DataTable16
   \   00000018   901526E0           MLA      R6,R0,R5,R1
    963              
    964              // Check that endpoint is enabled and not already in Halt state
    965              if ((pEndpoint->state != UDP_ENDPOINT_DISABLED)
    966                  && (pEndpoint->state != UDP_ENDPOINT_HALTED)) {
   \   0000001C   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0000D615           LDRBNE   R0,[R6, #+0]
   \   00000028   01005013           CMPNE    R0,#+1
   \   0000002C   1500000A           BEQ      ??USBD_Halt_0
    967          
    968                  TRACE_DEBUG_WP("Halt%d ", bEndpoint);
    969          
    970                  // Abort the current transfer if necessary
    971                  UDP_EndOfTransfer(bEndpoint, USBD_STATUS_ABORTED);
   \   00000030   0210A0E3           MOV      R1,#+2
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       UDP_EndOfTransfer
    972          
    973                  // Put endpoint into Halt state
    974                  SET_CSR(bEndpoint, AT91C_UDP_FORCESTALL);
   \   0000003C   ........           LDR      R0,??DataTable16_1  ;; 0xfffb0030
   \   00000040   051190E7           LDR      R1,[R0, +R5, LSL #+2]
   \   00000044   00108DE5           STR      R1,[SP, #+0]
   \   00000048   00109DE5           LDR      R1,[SP, #+0]
   \   0000004C   4F1081E3           ORR      R1,R1,#0x4F
   \   00000050   00108DE5           STR      R1,[SP, #+0]
   \   00000054   00109DE5           LDR      R1,[SP, #+0]
   \   00000058   201081E3           ORR      R1,R1,#0x20
   \   0000005C   00108DE5           STR      R1,[SP, #+0]
   \   00000060   00109DE5           LDR      R1,[SP, #+0]
   \   00000064   051180E7           STR      R1,[R0, +R5, LSL #+2]
   \                     ??USBD_Halt_1:
   \   00000068   051190E7           LDR      R1,[R0, +R5, LSL #+2]
   \   0000006C   200011E3           TST      R1,#0x20
   \   00000070   FCFFFF0A           BEQ      ??USBD_Halt_1
    975                  pEndpoint->state = UDP_ENDPOINT_HALTED;
   \   00000074   0100A0E3           MOV      R0,#+1
   \   00000078   0000C6E5           STRB     R0,[R6, #+0]
    976          
    977                  // Enable the endpoint interrupt
    978                  AT91C_BASE_UDP->UDP_IER = 1 << bEndpoint;
   \   0000007C   1004A0E1           LSL      R0,R0,R4
   \   00000080   ........           LDR      R1,??DataTable16_5  ;; 0xfffb0010
   \   00000084   000081E5           STR      R0,[R1, #+0]
    979              }
    980          }
   \                     ??USBD_Halt_0:
   \   00000088   7340BDE8           POP      {R0,R1,R4-R6,LR}
   \   0000008C   1EFF2FE1           BX       LR               ;; return
    981          
    982          //------------------------------------------------------------------------------
    983          /// Clears the Halt feature on the given endpoint.
    984          /// \param bEndpoint Index of endpoint
    985          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    986          void USBD_Unhalt(unsigned char bEndpoint)
    987          {
   \                     USBD_Unhalt:
   \   00000000   04D04DE2           SUB      SP,SP,#+4
    988              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   \   00000004   0010A0E1           MOV      R1,R0
   \   00000008   1C30A0E3           MOV      R3,#+28
   \   0000000C   ........           LDR      R2,??DataTable16
   \   00000010   932122E0           MLA      R2,R3,R1,R2
    989          
    990              // Check if the endpoint is enabled
    991              if (pEndpoint->state != UDP_ENDPOINT_DISABLED) {
   \   00000014   0030D2E5           LDRB     R3,[R2, #+0]
   \   00000018   000053E3           CMP      R3,#+0
   \   0000001C   1800000A           BEQ      ??USBD_Unhalt_0
    992          
    993                  TRACE_DEBUG_WP("Unhalt%d ", bEndpoint);
    994          
    995                  // Return endpoint to Idle state
    996                  pEndpoint->state = UDP_ENDPOINT_IDLE;
   \   00000020   0230A0E3           MOV      R3,#+2
   \   00000024   0030C2E5           STRB     R3,[R2, #+0]
    997          
    998                  // Clear FORCESTALL flag
    999                  CLEAR_CSR(bEndpoint, AT91C_UDP_FORCESTALL);
                         ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \   00000028   ........           LDR      R2,??DataTable16_1  ;; 0xfffb0030
   \   0000002C   013192E7           LDR      R3,[R2, +R1, LSL #+2]
   \   00000030   00308DE5           STR      R3,[SP, #+0]
   \   00000034   00309DE5           LDR      R3,[SP, #+0]
   \   00000038   4F3083E3           ORR      R3,R3,#0x4F
   \   0000003C   00308DE5           STR      R3,[SP, #+0]
   \   00000040   00309DE5           LDR      R3,[SP, #+0]
   \   00000044   2030C3E3           BIC      R3,R3,#0x20
   \   00000048   00308DE5           STR      R3,[SP, #+0]
   \   0000004C   00309DE5           LDR      R3,[SP, #+0]
   \   00000050   013182E7           STR      R3,[R2, +R1, LSL #+2]
   \                     ??USBD_Unhalt_1:
   \   00000054   013192E7           LDR      R3,[R2, +R1, LSL #+2]
   \   00000058   200013E3           TST      R3,#0x20
   \   0000005C   FCFFFF1A           BNE      ??USBD_Unhalt_1
   \   00000060   0110A0E3           MOV      R1,#+1
   \   00000064   1100A0E1           LSL      R0,R1,R0
   \   00000068   081042E2           SUB      R1,R2,#+8
   \   0000006C   002091E5           LDR      R2,[R1, #+0]
   \   00000070   022080E1           ORR      R2,R0,R2
   \   00000074   002081E5           STR      R2,[R1, #+0]
   1000          
   1001                  // Reset Endpoint Fifos, beware this is a 2 steps operation
   1002                  AT91C_BASE_UDP->UDP_RSTEP |= 1 << bEndpoint;
   1003                  AT91C_BASE_UDP->UDP_RSTEP &= ~(1 << bEndpoint);
   \   00000078   002091E5           LDR      R2,[R1, #+0]
   \   0000007C   0000C2E1           BIC      R0,R2,R0
   \   00000080   000081E5           STR      R0,[R1, #+0]
   1004              }
   1005          }
   \                     ??USBD_Unhalt_0:
   \   00000084                      REQUIRE ?Subroutine1
   \   00000084                      ;; // Fall through to label ?Subroutine1
   1006              
   1007          //------------------------------------------------------------------------------
   1008          /// Returns the current Halt status of an endpoint.
   1009          /// \param bEndpoint Index of endpoint
   1010          /// \return 1 if the endpoint is currently halted; otherwise 0
   1011          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
   1012          unsigned char USBD_IsHalted(unsigned char bEndpoint)
   1013          {
   1014              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   1015              unsigned char status = 0;
   \                     USBD_IsHalted:
   \   00000000   0010A0E3           MOV      R1,#+0
   1016          
   1017              if (pEndpoint->state == UDP_ENDPOINT_HALTED) {
   \   00000004   1C20A0E3           MOV      R2,#+28
   \   00000008   ........           LDR      R3,??DataTable16
   \   0000000C   923020E0           MLA      R0,R2,R0,R3
   \   00000010   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000014   010050E3           CMP      R0,#+1
   1018          
   1019                  status = 1;
   \   00000018   0110A003           MOVEQ    R1,#+1
   1020              }
   1021              return( status );
   \   0000001C   0100A0E1           MOV      R0,R1
   \   00000020   1EFF2FE1           BX       LR               ;; return
   1022          }
   1023          
   1024          //------------------------------------------------------------------------------
   1025          /// Indicates if the device is running in high or full-speed. Always returns 0
   1026          /// since UDP does not support high-speed mode.
   1027          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
   1028          unsigned char USBD_IsHighSpeed(void)
   1029          {
   1030              return 0;
   \                     USBD_IsHighSpeed:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return
   1031          }
   1032          
   1033          //------------------------------------------------------------------------------
   1034          /// Causes the given endpoint to acknowledge the next packet it receives
   1035          /// with a STALL handshake.
   1036          /// \param bEndpoint Endpoint number.
   1037          /// \return USBD_STATUS_SUCCESS or USBD_STATUS_LOCKED.
   1038          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
   1039          unsigned char USBD_Stall(unsigned char bEndpoint)
   1040          
   1041          {
   \                     USBD_Stall:
   \   00000000   00502DE9           PUSH     {R12,LR}
   1042              Endpoint *pEndpoint = &(endpoints[bEndpoint]);
   1043          
   1044              // Check that endpoint is in Idle state
   1045              if (pEndpoint->state != UDP_ENDPOINT_IDLE) {
   \   00000004   1C10A0E3           MOV      R1,#+28
   \   00000008   ........           LDR      R2,??DataTable16
   \   0000000C   912022E0           MLA      R2,R1,R0,R2
   \   00000010   0010D2E5           LDRB     R1,[R2, #+0]
   \   00000014   020051E3           CMP      R1,#+2
   \   00000018   0400000A           BEQ      ??USBD_Stall_0
   1046          
   1047                  TRACE_WARNING("UDP_Stall: Endpoint%d locked\n\r", bEndpoint);
   \   0000001C   0010A0E1           MOV      R1,R0
   \   00000020   ........           LDR      R0,??DataTable16_7
   \   00000024   ........           BL       printf
   1048                  return USBD_STATUS_LOCKED;
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   0E0000EA           B        ??USBD_Stall_1
   1049              }
   1050          
   1051              TRACE_DEBUG_WP("Stall%d ", bEndpoint);
   1052              SET_CSR(bEndpoint, AT91C_UDP_FORCESTALL);
   \                     ??USBD_Stall_0:
   \   00000030   ........           LDR      R1,??DataTable16_1  ;; 0xfffb0030
   \   00000034   002191E7           LDR      R2,[R1, +R0, LSL #+2]
   \   00000038   00208DE5           STR      R2,[SP, #+0]
   \   0000003C   00209DE5           LDR      R2,[SP, #+0]
   \   00000040   4F2082E3           ORR      R2,R2,#0x4F
   \   00000044   00208DE5           STR      R2,[SP, #+0]
   \   00000048   00209DE5           LDR      R2,[SP, #+0]
   \   0000004C   202082E3           ORR      R2,R2,#0x20
   \   00000050   00208DE5           STR      R2,[SP, #+0]
   \   00000054   00209DE5           LDR      R2,[SP, #+0]
   \   00000058   002181E7           STR      R2,[R1, +R0, LSL #+2]
   \                     ??USBD_Stall_2:
   \   0000005C   002191E7           LDR      R2,[R1, +R0, LSL #+2]
   \   00000060   200012E3           TST      R2,#0x20
   \   00000064   FCFFFF0A           BEQ      ??USBD_Stall_2
   1053          
   1054              return USBD_STATUS_SUCCESS;
   \   00000068   0000A0E3           MOV      R0,#+0
   \                     ??USBD_Stall_1:
   \   0000006C   0240BDE8           POP      {R1,LR}
   \   00000070   1EFF2FE1           BX       LR               ;; return
   1055          }
   1056          
   1057          //------------------------------------------------------------------------------
   1058          /// Starts a remote wake-up procedure.
   1059          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
   1060          void USBD_RemoteWakeUp(void)
   1061          {
   1062              UDP_EnablePeripheralClock();
   \                     USBD_RemoteWakeUp:
   \   00000000   1000A0E3           MOV      R0,#+16
   \   00000004   801EA0E3           MOV      R1,#+2048
   \   00000008   001400E5           STR      R1,[R0, #-1024]
   1063              UDP_EnableUsbClock();
   \   0000000C   FF00E0E3           MVN      R0,#+255
   \   00000010   C00FC0E3           BIC      R0,R0,#0x300
   \   00000014   8010A0E3           MOV      R1,#+128
   \   00000018   001080E5           STR      R1,[R0, #+0]
   1064              UDP_EnableTransceiver();
   \   0000001C   ........           LDR      R0,??DataTable16_8  ;; 0xfffb0004
   \   00000020   701090E5           LDR      R1,[R0, #+112]
   \   00000024   401FC1E3           BIC      R1,R1,#0x100
   \   00000028   701080E5           STR      R1,[R0, #+112]
   1065          
   1066              TRACE_INFO_WP("RWUp ");
   1067          
   1068              // Activates a remote wakeup (edge on ESR), then clear ESR
   1069              AT91C_BASE_UDP->UDP_GLBSTATE |= AT91C_UDP_ESR;
   \   0000002C   001090E5           LDR      R1,[R0, #+0]
   \   00000030   041081E3           ORR      R1,R1,#0x4
   \   00000034   001080E5           STR      R1,[R0, #+0]
   1070              AT91C_BASE_UDP->UDP_GLBSTATE &= ~AT91C_UDP_ESR;
                                                     ^
Remark[Pe068]: integer conversion resulted in a change of sign

              ((TransferCallback) pTransfer->fCallback)
              ^
"C:\Projects\in-18-nixie-clock\at91lib\usb\device\core\USBD_UDP.c",261  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

          pTransfer->buffered += wPacketSize - pTransfer->remaining;
          ^
"C:\Projects\in-18-nixie-clock\at91lib\usb\device\core\USBD_UDP.c",343  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

          return (pTransfer->buffered < pEndpoint->size);
          ^
"C:\Projects\in-18-nixie-clock\at91lib\usb\device\core\USBD_UDP.c",441  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

          return (pTransfer->buffered <= pEndpoint->size)
          ^
"C:\Projects\in-18-nixie-clock\at91lib\usb\device\core\USBD_UDP.c",446  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

                  pTransfer->transferred += pTransfer->buffered;
                  ^
"C:\Projects\in-18-nixie-clock\at91lib\usb\device\core\USBD_UDP.c",479  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

                  pTransfer->transferred += pEndpoint->size;
                  ^
"C:\Projects\in-18-nixie-clock\at91lib\usb\device\core\USBD_UDP.c",496  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

                  pTransfer->buffered -= pEndpoint->size;
                  ^
"C:\Projects\in-18-nixie-clock\at91lib\usb\device\core\USBD_UDP.c",497  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
   \   00000038   001090E5           LDR      R1,[R0, #+0]
   \   0000003C   0410C1E3           BIC      R1,R1,#0x4
   \   00000040   001080E5           STR      R1,[R0, #+0]
   1071          }
   \   00000044   1EFF2FE1           BX       LR               ;; return
   1072          
   1073          //------------------------------------------------------------------------------
   1074          /// Sets the device address to the given value.
   1075          /// \param address New device address.
   1076          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
   1077          void USBD_SetAddress(unsigned char address)
   1078          {
   1079              TRACE_INFO_WP("SetAddr(%d) ", address);
   1080          
   1081              // Set address
   1082              AT91C_BASE_UDP->UDP_FADDR = AT91C_UDP_FEN | address;
   \                     USBD_SetAddress:
   \   00000000   ........           LDR      R1,??DataTable16_8  ;; 0xfffb0004
   \   00000004   402F80E3           ORR      R2,R0,#0x100
   \   00000008   042081E5           STR      R2,[R1, #+4]
   1083          
   1084              // If the address is 0, the device returns to the Default state
   1085              if (address == 0) {
   \   0000000C   000050E3           CMP      R0,#+0
   1086          
   1087                  AT91C_BASE_UDP->UDP_GLBSTATE = 0;
   \   00000010   00008105           STREQ    R0,[R1, #+0]
   1088                  deviceState = USBD_STATE_DEFAULT;
   \   00000014   0300A003           MOVEQ    R0,#+3
   1089              }
   1090              // If the address is non-zero, the device enters the Address state
   1091              else {
   1092          
   1093                  AT91C_BASE_UDP->UDP_GLBSTATE = AT91C_UDP_FADDEN;
   \   00000018   0100A013           MOVNE    R0,#+1
   \   0000001C   00008115           STRNE    R0,[R1, #+0]
   1094                  deviceState = USBD_STATE_ADDRESS;
   \   00000020   0400A013           MOVNE    R0,#+4
   \   00000024   ........           LDR      R1,??DataTable16_6
   \   00000028   0000C1E5           STRB     R0,[R1, #+0]
   1095              }
   1096          }
   \   0000002C   1EFF2FE1           BX       LR               ;; return
   1097          
   1098          //------------------------------------------------------------------------------
   1099          /// Sets the current device configuration.
   1100          /// \param cfgnum - Configuration number to set.
   1101          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
   1102          void USBD_SetConfiguration(unsigned char cfgnum)
   1103          {
   \                     USBD_SetConfiguration:
   \   00000000   00502DE9           PUSH     {R12,LR}
   1104              TRACE_INFO_WP("SetCfg(%d) ", cfgnum);
   1105          
   1106              // If the configuration number if non-zero, the device enters the
   1107              // Configured state
   1108              if (cfgnum != 0) {
   \   00000004   ........           LDR      R1,??DataTable16_8  ;; 0xfffb0004
   \   00000008   ........           LDR      R2,??DataTable16_6
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0500000A           BEQ      ??USBD_SetConfiguration_0
   1109          
   1110                  // Enter Configured state
   1111                  deviceState = USBD_STATE_CONFIGURED;
   \   00000014   0500A0E3           MOV      R0,#+5
   \   00000018   0000C2E5           STRB     R0,[R2, #+0]
   1112                  AT91C_BASE_UDP->UDP_GLBSTATE |= AT91C_UDP_CONFG;
   \   0000001C   000091E5           LDR      R0,[R1, #+0]
   \   00000020   020080E3           ORR      R0,R0,#0x2
   \   00000024   000081E5           STR      R0,[R1, #+0]
   \   00000028   040000EA           B        ??USBD_SetConfiguration_1
   1113              }
   1114              // If the configuration number is zero, the device goes back to the Address
   1115              // state
   1116              else {
   1117          
   1118                  deviceState = USBD_STATE_ADDRESS;
   \                     ??USBD_SetConfiguration_0:
   \   0000002C   0400A0E3           MOV      R0,#+4
   \   00000030   0000C2E5           STRB     R0,[R2, #+0]
   1119                  AT91C_BASE_UDP->UDP_GLBSTATE = AT91C_UDP_FADDEN;
   \   00000034   0100A0E3           MOV      R0,#+1
   \   00000038   000081E5           STR      R0,[R1, #+0]
   1120          
   1121                  // Abort all transfers
   1122                  UDP_DisableEndpoints();
   \   0000003C   ........           BL       UDP_DisableEndpoints
   1123              }
   1124          }
   \                     ??USBD_SetConfiguration_1:
   \   00000040                      REQUIRE ?Subroutine0
   \   00000040                      ;; // Fall through to label ?Subroutine0
   1125          
   1126          //------------------------------------------------------------------------------
   1127          /// Connects the pull-up on the D+ line of the USB.
   1128          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
   1129          void USBD_Connect(void)
   1130          {
   \                     USBD_Connect:
   \   00000000   005C2DE9           PUSH     {R10-R12,LR}
   1131              TRACE_DEBUG("Conn ");
   1132          
   1133          #if defined(BOARD_USB_PULLUP_EXTERNAL)
   1134              const Pin pinPullUp = PIN_USB_PULLUP;
   \   00000004   0D00A0E1           MOV      R0,SP
   \   00000008   ........           LDR      R1,??DataTable16_9
   \   0000000C   0C10B1E8           LDM      R1!,{R2,R3,R12}
   \   00000010   0C10A0E8           STM      R0!,{R2,R3,R12}
   1135              if (pinPullUp.attribute == PIO_OUTPUT_0) {
   \   00000014   0A00DDE5           LDRB     R0,[SP, #+10]
   \   00000018   030050E3           CMP      R0,#+3
   \   0000001C   0D00A0E1           MOV      R0,SP
   \   00000020   0100001A           BNE      ??USBD_Connect_0
   1136          
   1137                  PIO_Set(&pinPullUp);
   \   00000024   ........           BL       PIO_Set
   \   00000028   000000EA           B        ??USBD_Connect_1
   1138              }
   1139              else {
   1140          
   1141                  PIO_Clear(&pinPullUp);
   \                     ??USBD_Connect_0:
   \   0000002C   ........           BL       PIO_Clear
   1142              }
   1143          #elif defined(BOARD_USB_PULLUP_INTERNAL)
   1144              AT91C_BASE_UDP->UDP_TXVC |= AT91C_UDP_PUON;
   1145          #elif defined(BOARD_USB_PULLUP_MATRIX)
   1146              AT91C_BASE_MATRIX->MATRIX_USBPCR |= AT91C_MATRIX_USBPCR_PUON;
   1147          #elif !defined(BOARD_USB_PULLUP_ALWAYSON)
   1148              #error Unsupported pull-up type.
   1149          #endif
   1150          }
   \                     ??USBD_Connect_1:
   \   00000030   ........           B        ?Subroutine3

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0740BDE8           POP      {R0-R2,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
   1151          
   1152          //------------------------------------------------------------------------------
   1153          /// Disconnects the pull-up from the D+ line of the USB.
   1154          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
   1155          void USBD_Disconnect(void)
   1156          {
   \                     USBD_Disconnect:
   \   00000000   005C2DE9           PUSH     {R10-R12,LR}
   1157              TRACE_DEBUG("Disc ");
   1158          
   1159          #if defined(BOARD_USB_PULLUP_EXTERNAL)
   1160              const Pin pinPullUp = PIN_USB_PULLUP;
   \   00000004   0D00A0E1           MOV      R0,SP
   \   00000008   ........           LDR      R1,??DataTable16_10
   \   0000000C   0C10B1E8           LDM      R1!,{R2,R3,R12}
   \   00000010   0C10A0E8           STM      R0!,{R2,R3,R12}
   1161              if (pinPullUp.attribute == PIO_OUTPUT_0) {
   \   00000014   0A00DDE5           LDRB     R0,[SP, #+10]
   \   00000018   030050E3           CMP      R0,#+3
   \   0000001C   0D00A0E1           MOV      R0,SP
   \   00000020   0100001A           BNE      ??USBD_Disconnect_0
   1162          
   1163                  PIO_Clear(&pinPullUp);
   \   00000024   ........           BL       PIO_Clear
   \   00000028   000000EA           B        ??USBD_Disconnect_1
   1164              }
   1165              else {
   1166          
   1167                  PIO_Set(&pinPullUp);
   \                     ??USBD_Disconnect_0:
   \   0000002C   ........           BL       PIO_Set
   1168              }
   1169          #elif defined(BOARD_USB_PULLUP_INTERNAL)
   1170              AT91C_BASE_UDP->UDP_TXVC &= ~AT91C_UDP_PUON;
   1171          #elif defined(BOARD_USB_PULLUP_MATRIX)
   1172              AT91C_BASE_MATRIX->MATRIX_USBPCR &= ~AT91C_MATRIX_USBPCR_PUON;
   1173          #elif !defined(BOARD_USB_PULLUP_ALWAYSON)
   1174              #error Unsupported pull-up type.
   1175          #endif
   1176          
   1177              // Device returns to the Powered state
   1178              if (deviceState > USBD_STATE_POWERED) {
   \                     ??USBD_Disconnect_1:
   \   00000030   0200A0E3           MOV      R0,#+2
   \   00000034   ........           LDR      R1,??DataTable16_6
   \   00000038   0020D1E5           LDRB     R2,[R1, #+0]
   \   0000003C   030052E3           CMP      R2,#+3
   1179              
   1180                  deviceState = USBD_STATE_POWERED;
   \   00000040   0000C125           STRBCS   R0,[R1, #+0]
   1181              }
   1182          
   1183              if (previousDeviceState > USBD_STATE_POWERED) {
   \   00000044   0120D1E5           LDRB     R2,[R1, #+1]
   \   00000048   030052E3           CMP      R2,#+3
   1184          
   1185                  previousDeviceState = USBD_STATE_POWERED;
   \   0000004C   0100C125           STRBCS   R0,[R1, #+1]
   1186              }
   1187          }
   \   00000050                      REQUIRE ?Subroutine3
   \   00000050                      ;; // Fall through to label ?Subroutine3
   1188          
   1189          //------------------------------------------------------------------------------
   1190          /// Initializes the USB driver.
   1191          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
   1192          void USBD_Init(void)
   1193          {
   \                     USBD_Init:
   \   00000000   005C2DE9           PUSH     {R10-R12,LR}
   1194              TRACE_INFO_WP("USBD_Init\n\r");
   1195          
   1196              // Reset endpoint structures
   1197              UDP_ResetEndpoints();
   \   00000004   ........           BL       UDP_ResetEndpoints
   1198          
   1199              // Configure the pull-up on D+ and disconnect it
   1200          #if defined(BOARD_USB_PULLUP_EXTERNAL)
   1201              const Pin pinPullUp = PIN_USB_PULLUP;
   \   00000008   0D00A0E1           MOV      R0,SP
   \   0000000C   ........           LDR      R1,??DataTable16_11
   \   00000010   0C10B1E8           LDM      R1!,{R2,R3,R12}
   \   00000014   0C10A0E8           STM      R0!,{R2,R3,R12}
   1202              PIO_Configure(&pinPullUp, 1);
   \   00000018   0110A0E3           MOV      R1,#+1
   \   0000001C   0D00A0E1           MOV      R0,SP
   \   00000020   ........           BL       PIO_Configure
   1203          #elif defined(BOARD_USB_PULLUP_INTERNAL)
   1204              AT91C_BASE_UDP->UDP_TXVC &= ~AT91C_UDP_PUON;
   1205          #elif defined(BOARD_USB_PULLUP_MATRIX)
   1206              AT91C_BASE_MATRIX->MATRIX_USBPCR &= ~AT91C_MATRIX_USBPCR_PUON;
   1207          #elif !defined(BOARD_USB_PULLUP_ALWAYSON)
   1208              #error Missing pull-up definition.
   1209          #endif
   1210          
   1211              // Device is in the Attached state
   1212              deviceState = USBD_STATE_SUSPENDED;
   \   00000024   ........           LDR      R0,??DataTable16_6
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   0010C0E5           STRB     R1,[R0, #+0]
   1213              previousDeviceState = USBD_STATE_POWERED;
   \   00000030   0210A0E3           MOV      R1,#+2
   \   00000034   0110C0E5           STRB     R1,[R0, #+1]
   1214              UDP_EnablePeripheralClock();
   \   00000038   1000A0E3           MOV      R0,#+16
   \   0000003C   801EA0E3           MOV      R1,#+2048
   \   00000040   001400E5           STR      R1,[R0, #-1024]
   1215              UDP_EnableUsbClock();
   \   00000044   FF00E0E3           MVN      R0,#+255
   \   00000048   C00FC0E3           BIC      R0,R0,#0x300
   \   0000004C   8010A0E3           MOV      R1,#+128
   \   00000050   001080E5           STR      R1,[R0, #+0]
   1216          
   1217              AT91C_BASE_UDP->UDP_IDR = 0xFE;
   \   00000054   ........           LDR      R0,??DataTable16_5  ;; 0xfffb0010
   \   00000058   FE10A0E3           MOV      R1,#+254
   \   0000005C   041080E5           STR      R1,[R0, #+4]
   1218          
   1219              AT91C_BASE_UDP->UDP_IER = AT91C_UDP_WAKEUP;
   \   00000060   801DA0E3           MOV      R1,#+8192
   \   00000064   001080E5           STR      R1,[R0, #+0]
   1220          
   1221              // Configure interrupts
   1222              USBDCallbacks_Initialized();
   \   00000068   ........           BL       USBDCallbacks_Initialized
   1223          }
   \   0000006C   ........           B        ?Subroutine3
   1224          
   1225          //------------------------------------------------------------------------------
   1226          /// Configure USB Speed, should be invoked before USB attachment.
   1227          /// \param forceFS Force to use FS mode.
   1228          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
   1229          void USBD_ConfigureSpeed(unsigned char forceFS)
   1230          {
   1231          }
   \                     USBD_ConfigureSpeed:
   \   00000000   1EFF2FE1           BX       LR               ;; return
   1232          
   1233          //------------------------------------------------------------------------------
   1234          /// Returns the current state of the USB device.
   1235          /// \return Device current state.
   1236          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
   1237          unsigned char USBD_GetState(void)
   1238          {
   1239              return deviceState;
   \                     USBD_GetState:
   \   00000000   ........           LDR      R0,??DataTable16_6
   \   00000004   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000008   1EFF2FE1           BX       LR               ;; return
   1240          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     endpoints

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   3000FBFF           DC32     0xfffb0030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   5000FBFF           DC32     0xfffb0050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   ........           DC32     `?<Constant "-E- Error Wr">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0007FF07           DC32     0x7ff0700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   1000FBFF           DC32     0xfffb0010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   ........           DC32     deviceState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   ........           DC32     `?<Constant "-W- UDP_Stall: Endpoi...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0400FBFF           DC32     0xfffb0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   ........           DC32     `?<Constant {65536, (AT91S_PIO *)4294964224, 2,`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   ........           DC32     `?<Constant {65536, (AT91S_PIO *)4294964224, 2,_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   ........           DC32     `?<Constant {65536, (AT91S_PIO *)4294964224, 2,_2`

   \                                 In section .rodata, align 4
   \                     `?<Constant "-E- Error Wr">`:
   \   00000000   2D452D204572       DC8 "-E- Error Wr"
   \              726F72205772
   \              00          
   \   0000000D   000000             DC8 0, 0, 0
   \   00000010   2D572D205374       DC8 "-W- Sta 0x%X [%d] "
   \              612030782558
   \              205B25645D20
   \              00          
   \   00000023   00                 DC8 0
   \   00000024   2D572D205F20       DC8 "-W- _ "
   \              00          
   \   0000002B   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-W- UDP_Stall: Endpoi...">`:
   \   00000000   2D572D205544       DC8 "-W- UDP_Stall: Endpoint%d locked\012\015"
   \              505F5374616C
   \              6C3A20456E64
   \              706F696E7425
   \              64206C6F636B
   \              65640A0D00  
   \   00000023   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {65536, (AT91S_PIO *)4294964224, 2,`:
   \   00000000   0000010000F4       DC32 65536, 0FFFFF400H
   \              FFFF        
   \   00000008   02040000           DC8 2, 4, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {65536, (AT91S_PIO *)4294964224, 2,_1`:
   \   00000000   0000010000F4       DC32 65536, 0FFFFF400H
   \              FFFF        
   \   00000008   02040000           DC8 2, 4, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {65536, (AT91S_PIO *)4294964224, 2,_2`:
   \   00000000   0000010000F4       DC32 65536, 0FFFFF400H
   \              FFFF        
   \   00000008   02040000           DC8 2, 4, 0, 0
   1241          
   1242          #endif // BOARD_USB_UDP

   Maximum stack usage in bytes:

     Function               .cstack
     --------               -------
     UDPD_IrqHandler            40
     UDP_ClearRxFlag             8
     UDP_DisableEndpoints       16
     UDP_EndOfTransfer           8
     UDP_EndpointHandler        56
     UDP_ResetEndpoints          4
     UDP_WritePayload            4
     USBD_ConfigureEndpoint     32
     USBD_ConfigureSpeed         0
     USBD_Connect               16
     USBD_Disconnect            16
     USBD_GetState               0
     USBD_Halt                  24
     USBD_Init                  16
     USBD_IsHalted               0
     USBD_IsHighSpeed            0
     USBD_Read                  12
     USBD_RemoteWakeUp           0
     USBD_SetAddress             0
     USBD_SetConfiguration       8
     USBD_Stall                  8
     USBD_Unhalt                 4
     USBD_Write                 24


   Section sizes:

     Function/Label                                   Bytes
     --------------                                   -----
     endpoints                                         112
     deviceState                                         2
     previousDeviceState
     UDP_EndOfTransfer                                  96
     ?Subroutine0                                        8
     UDP_ClearRxFlag                                   172
     ?Subroutine1                                        8
     UDP_WritePayload                                  100
     ?Subroutine2                                        8
     UDP_ResetEndpoints                                 76
     UDP_DisableEndpoints                               60
     UDP_EndpointHandler                              1152
     UDPD_IrqHandler                                   384
     USBD_ConfigureEndpoint                            260
     USBD_Write                                        220
     USBD_Read                                         108
     USBD_Halt                                         144
     USBD_Unhalt                                       132
     USBD_IsHalted                                      36
     USBD_IsHighSpeed                                    8
     USBD_Stall                                        116
     USBD_RemoteWakeUp                                  72
     USBD_SetAddress                                    48
     USBD_SetConfiguration                              64
     USBD_Connect                                       52
     ?Subroutine3                                        8
     USBD_Disconnect                                    80
     USBD_Init                                         112
     USBD_ConfigureSpeed                                 4
     USBD_GetState                                      12
     ??DataTable16                                       4
     ??DataTable16_1                                     4
     ??DataTable16_2                                     4
     ??DataTable16_3                                     4
     ??DataTable16_4                                     4
     ??DataTable16_5                                     4
     ??DataTable16_6                                     4
     ??DataTable16_7                                     4
     ??DataTable16_8                                     4
     ??DataTable16_9                                     4
     ??DataTable16_10                                    4
     ??DataTable16_11                                    4
     ?<Constant "-E- Error Wr">                         44
     ?<Constant "-W- UDP_Stall: Endpoi...">             36
     ?<Constant {65536, (AT91S_PIO *)4294964224, 2,     12
     ?<Constant {65536, (AT91S_PIO *)4294964224, 2,_1   12
     ?<Constant {65536, (AT91S_PIO *)4294964224, 2,_2   12

 
   114 bytes in section .bss
   116 bytes in section .rodata
 3 588 bytes in section .text
 
 3 588 bytes of CODE  memory
   116 bytes of CONST memory
   114 bytes of DATA  memory

Errors: none
Warnings: 7
